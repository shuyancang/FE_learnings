


# js设计模式

* 模式, 更侧重与意图, 而非实现

## 1，单例模式：确保只有一个实例，提供全局访问；
* 用途: 界面/信息, 明确知道只有一个(弹框/登录效果等), 使用时创建, 不使用时隐藏, 再次点击时只需继续展示即可
* 核心: var singleLeton; if(!singleLeton){ createSingleLeton }
```javascript
var getSingle = function(fn){ // 抽象公用
  var result;
  return function(){
    return result || (result = fn.apply(this, arguments))
  }
}
```

## 2. 策略模式
* 定义一系列算法, 封装, 且使得其可以互相替换;
* 组成: 策略 + 环境类;
* 本质上, 是将一系列业务的逻辑实现前奏, 进行拆分 => 形成互不依赖的各个独立/可复用小块; 使用时自由组合, 再注入业务实现代码;避免过多的业务if-else条件判断及依次执行的耦合的业务代码;
* js中, 高阶函数其实是一种常见的策略模式;

## 3. 代理模式 
* 为一个对象提供一个代用品或占位符, 以便控制对其的访问;
* 保护代理: 代理帮目标过滤掉一部分业务/行为; 虚拟代理: 代理在某种条件下再转发业务/行为至目标; 缓存代理: 为部分开销大的计算暂存;
* 单一职责原则: 一个类/对象/函数, 应该仅有一个引起他变化的原因;(优先-若承担多职责会导致变得臃肿且难以分析)
* 代理应和本体接口保持一致;
* 其余代理: 防火墙代理, 远程代理, 智能引用代理, 写时复制代理

## 4. 迭代器模式
* 提供一个方法, 访问一个聚合对象中的各个元素
* 内部迭代器 each,map,filter等 - 不能同时迭代多个数组/内容
* 外部迭代器 显式迭代下一个元素的方法
* 可以将相同的交互/条件/情况进行集合, 组成一个可迭代对象, 迭代业务

## 5. 发布订阅模式
* 定义对象间的一种一对多依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都将得到通知。
* DOM.addEventListener是一种发布订阅模式 - 订阅事件，事件触发时发布到对应的回调。
* 发布者 + 订阅者回调列表, 订阅+取消订阅功能
* listen订阅, removeListen取消订阅, cacheList订阅缓存列表,
* 能够有效的解耦，在各自的业务逻辑内加载自己所需的依赖，但若随意、无序的添加各类发布订阅，会导致发布者的维护变得困难 - 你不知道自己的改动会影响到底哪些订阅者。故需要谨慎，有序，有目的，有文档的建立安全的发布订阅的关系。

## 6. 命令模式
* 松耦合的方式设计程序, 执行某些特定的指令; 何时调用何时执行, 与调用者消除耦合, 提供调用入口, 反馈结果即可, 还支持撤销队列等操作;
* 命令模式: 交互封装(谁, 做什么); 是回调函数的一个替代品;
* 实际上, 命令模式可以理解为部分非耦合执行步骤的抽离, 供业务逻辑对象调用/取消调用
* 命令队列(多命令推入一个执行队列依次执行), 宏命令(一组命令集合, 一次执行一批命令), 智能命令(直接实现, 不依赖于执行者 - 与策略模式很像), 傻瓜命令(执行者, 执行内容),

## 7. 组合模式
* React组件, Vue组件, js模块化引入实际上都是组合模式的一种思路体现;
* 对象组合成树形结构标识"整体-部分"的层次结构, 提供一种更加有层次, 相似性的整体结构; 结构性+相似性。

## 8. 模板方法模式
* 一种基于继承的设计模式, 由抽象父类(子类的算法框架)+实现子类(具体实现, 并可以重写父类方法)构成;
* 模板方法模式: 设计搭建项目框架(模板方法)后, 基于框架进行业务实现;
* 钩子方法: 放置钩子-隔离变化的一种常用手段;
* 好莱坞原则: 允许底层组件将自己挂钩到高层组件中, 高层组件会决定什么时候/何种方式使用底层组件;

## 9. 享元模式
* 一种用于性能优化的模式, 核心是运用共享技术来有效支持大量细粒度的对象; - 创建大量类似对象而导致内存过高时, 享元模式非常有用;
* 将对象的属性划分为内部状态和外部状态, 尽量降低共享对象的数量;
* 内部状态存储于对象内部, 可以被一些对象共享, 内部状态对立于具体的场景, 通常不会改变; 外部状态取决于具体的场景, 不被共享;
* 时间换空间: 使用大量相似对象造成很大内存开销并可进行剥离时, 可考虑使用;

## 10. 职责链模式
* 使多个对象都有机会处理请求, 从而避免请求的发送者和接受者之间的耦合关系, 将这种对象连成一条链并沿着这条链传递该请求, 知道有一个对象处理为止;
* 最大的作用: 解耦特定的业务函数与操作顺序;

## 11. 中介者模式
* 面向对象设计估计将行为分布到各个对象中, 把对象划分成更小的粒度, 有助于增强对象的可复用性, 但由于这些细粒度对象之间的联系激增, 又有可能反过来降低他们的可复用性;
* 中介者模式: 解除对象与对象之间的紧耦合关系, 增加中介者对象;

## 12. 装饰者模式















