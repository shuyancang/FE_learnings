


# js设计模式

* 模式, 更侧重与意图, 而非实现

## 1，单例模式：确保只有一个实例，提供全局访问；
* 用途: 界面/信息, 明确知道只有一个(弹框/登录效果等), 使用时创建, 不使用时隐藏, 再次点击时只需继续展示即可
* 核心: var singleLeton; if(!singleLeton){ createSingleLeton }
```javascript
var getSingle = function(fn){ // 抽象公用
  var result;
  return function(){
    return result || (result = fn.apply(this, arguments))
  }
}
```

## 2. 策略模式
* 定义一系列算法, 封装, 且使得其可以互相替换;
* 组成: 策略 + 环境类;
* 本质上, 是将一系列业务的逻辑实现前奏, 进行拆分 => 形成互不依赖的各个独立/可复用小块; 使用时自由组合, 再注入业务实现代码;避免过多的业务if-else条件判断及依次执行的耦合的业务代码;
* js中, 高阶函数其实是一种常见的策略模式;

## 3. 代理模式 
* 为一个对象提供一个代用品或占位符, 以便控制对其的访问;
* 保护代理: 代理帮目标过滤掉一部分业务/行为; 虚拟代理: 代理在某种条件下再转发业务/行为至目标; 缓存代理: 为部分开销大的计算暂存;
* 单一职责原则: 一个类/对象/函数, 应该仅有一个引起他变化的原因;(优先-若承担多职责会导致变得臃肿且难以分析)
* 代理应和本体接口保持一致;
* 其余代理: 防火墙代理, 远程代理, 智能引用代理, 写时复制代理

## 4. 迭代器模式
* 提供一个方法, 访问一个聚合对象中的各个元素
* 内部迭代器 each,map,filter等 - 不能同时迭代多个数组/内容
* 外部迭代器 显式迭代下一个元素的方法
* 可以将相同的交互/条件/情况进行集合, 组成一个可迭代对象, 迭代业务

## 5. 发布订阅模式
* 













