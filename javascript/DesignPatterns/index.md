


# js设计模式

* 模式, 更侧重与意图, 而非实现
* 基于无数实践总结的; 为了重用, 扩展, 解耦, 易维护/理解/可靠; 设计模式是的代码真正的工程化;
* 设计原则: 开闭-对扩展开放对修改关闭, 里氏转换原则-子类继承父类但也可以单独调用, 依赖倒转原则-引用一个有底层的对象可以直接引用底层, 接口隔离原则-每一个接口应该是一种角色, 合成/聚合复用原则-新对象应该使用一些已有对象使之成为新对象的一部分, 迪米特(最小知识)原则-一个对象对其他对象应该有尽可能少的了解;

## 1，单例模式：确保只有一个实例，提供全局访问；
* 用途: 界面/信息, 明确知道只有一个(弹框/登录效果等), 使用时创建, 不使用时隐藏, 再次点击时只需继续展示即可
* 核心: var singleLeton; if(!singleLeton){ createSingleLeton }
```javascript
var getSingle = function(fn){ // 抽象公用
  var result;
  return function(){
    return result || (result = fn.apply(this, arguments))
  }
}
```

## 2. 策略模式
* 定义一系列算法, 封装, 且使得其可以互相替换;
* 组成: 策略 + 环境类;
* 本质上, 是将一系列业务的逻辑实现前奏, 进行拆分 => 形成互不依赖的各个独立/可复用小块; 使用时自由组合, 再注入业务实现代码;避免过多的业务if-else条件判断及依次执行的耦合的业务代码;
* js中, 高阶函数其实是一种常见的策略模式;

## 3. 代理模式 
* 为一个对象提供一个代用品或占位符, 以便控制对其的访问;
* 保护代理: 代理帮目标过滤掉一部分业务/行为; 虚拟代理: 代理在某种条件下再转发业务/行为至目标; 缓存代理: 为部分开销大的计算暂存;
* 单一职责原则: 一个类/对象/函数, 应该仅有一个引起他变化的原因;(优先-若承担多职责会导致变得臃肿且难以分析)
* 代理应和本体接口保持一致;
* 其余代理: 防火墙代理, 远程代理, 智能引用代理, 写时复制代理

## 4. 迭代器模式
* 提供一个方法, 访问一个聚合对象中的各个元素
* 内部迭代器 each,map,filter等 - 不能同时迭代多个数组/内容
* 外部迭代器 显式迭代下一个元素的方法
* 可以将相同的交互/条件/情况进行集合, 组成一个可迭代对象, 迭代业务

## 5. 发布订阅模式
* 定义对象间的一种一对多依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都将得到通知。
* DOM.addEventListener是一种发布订阅模式 - 订阅事件，事件触发时发布到对应的回调。
* 发布者 + 订阅者回调列表, 订阅+取消订阅功能
* listen订阅, removeListen取消订阅, cacheList订阅缓存列表,
* 能够有效的解耦，在各自的业务逻辑内加载自己所需的依赖，但若随意、无序的添加各类发布订阅，会导致发布者的维护变得困难 - 你不知道自己的改动会影响到底哪些订阅者。故需要谨慎，有序，有目的，有文档的建立安全的发布订阅的关系。

## 6. 命令模式
* 松耦合的方式设计程序, 执行某些特定的指令; 何时调用何时执行, 与调用者消除耦合, 提供调用入口, 反馈结果即可, 还支持撤销队列等操作;
* 命令模式: 交互封装(谁, 做什么); 是回调函数的一个替代品;
* 实际上, 命令模式可以理解为部分非耦合执行步骤的抽离, 供业务逻辑对象调用/取消调用
* 命令队列(多命令推入一个执行队列依次执行), 宏命令(一组命令集合, 一次执行一批命令), 智能命令(直接实现, 不依赖于执行者 - 与策略模式很像), 傻瓜命令(执行者, 执行内容),

## 7. 组合模式
* React组件, Vue组件, js模块化引入实际上都是组合模式的一种思路体现;
* 对象组合成树形结构标识"整体-部分"的层次结构, 提供一种更加有层次, 相似性的整体结构; 结构性+相似性。

## 8. 模板方法模式
* 一种基于继承的设计模式, 由抽象父类(子类的算法框架)+实现子类(具体实现, 并可以重写父类方法)构成;
* 模板方法模式: 设计搭建项目框架(模板方法)后, 基于框架进行业务实现;
* 钩子方法: 放置钩子-隔离变化的一种常用手段;
* 好莱坞原则: 允许底层组件将自己挂钩到高层组件中, 高层组件会决定什么时候/何种方式使用底层组件;

## 9. 享元模式
* 一种用于性能优化的模式, 核心是运用共享技术来有效支持大量细粒度的对象; - 创建大量类似对象而导致内存过高时, 享元模式非常有用;
* 将对象的属性划分为内部状态和外部状态, 尽量降低共享对象的数量;
* 内部状态存储于对象内部, 可以被一些对象共享, 内部状态对立于具体的场景, 通常不会改变; 外部状态取决于具体的场景, 不被共享;
* 时间换空间: 使用大量相似对象造成很大内存开销并可进行剥离时, 可考虑使用;

## 10. 职责链模式
* 使多个对象都有机会处理请求, 从而避免请求的发送者和接受者之间的耦合关系, 将这种对象连成一条链并沿着这条链传递该请求, 知道有一个对象处理为止;
* 最大的作用: 解耦特定的业务函数与操作顺序;

## 11. 中介者模式
* 面向对象设计估计将行为分布到各个对象中, 把对象划分成更小的粒度, 有助于增强对象的可复用性, 但由于这些细粒度对象之间的联系激增, 又有可能反过来降低他们的可复用性;
* 中介者模式: 解除对象与对象之间的紧耦合关系, 增加中介者对象;

## 12. 装饰者模式
* 按需添加职责, 动态为某个对象添加一些额外的职责而不影响该类派生的其他对象;
* 将一个对象嵌入到另一个对象中, 实际上相当于这个对象被李宁一个对象包装起来, 形成一条包装链;
* AOP装饰函数: Function.prototype.before, Function.prototype.after => _self.apply(this.arguments); afterFn/beforeFn.apply(this, arguments); 避免this劫持;
* 装饰器模式与代理模式很相似; 代理: 当直接访问本体不方便或不符需求时为本体提供替代者,其本体提供关键功能,代理提供访问或访问前做额外事情; 装饰者模式:为对象动态加入行为; 代理强调Proxy与实体关系, 装饰者模式一开始不确定对象全部功能; 代理通常只要一层代理-本体的引用, 而装饰者通常形成装饰链;

## 13. 状态模式
* 把事物的每种状态都封装成单独的类, 区分事物内部状态带动事物行为的改变;
* 允许一个对象在其内部状态改变时改变它的行为, 对象看起来似乎修改了它的类;
* 状态模式定义了状态和行为间的关系,很容易增加新的状态和转换
* 避免context无限膨胀
* context的动作和状态的封装行为可以非常容易的独立变化而互不影响;
* 状态机;

## 14. 适配器模式
* 解决两个软件实体间接口不兼容的问题
* 很简单的一个模式, - 亡羊补牢。

# 第三部分 - 设计原则和编程技巧

## 15. 单一职责(SRP)原则
* 一个类/方法/对象, 应该仅有一个引起他变化的原因, 只做一件事情;
* 代理模式, 迭代器模式, 单例模式, 装饰者模式均可以在某些场景下, 满足单一职责, 可读解耦, 且便于维护;
* 优点: 降低单个类或对象的复杂度, 按照职责把对象分解成更小粒度有助于复用, 且变更时不会影响其他职责;
* 缺点: 增加编写代码的复杂度, 增大对象间互相联系的难度;
* 建议: 更多的是跟随需求进行职责分离, 只有当确定多个职责需要分离或必然变化时, 分离才有更好的收益, 在方便性和稳定性间, 面向需求进行取舍;

## 16. 最少知识(LKP)原则
* 一个软件实体应该尽可能少的与其他实体发生相互作用;
* 中介者模式和外观模式较多的体现了最少知识原则的思路;
* 最少知识原则要求我们在设计程序时尽量减少对象间的交互。如果两个对象间不必彼此直接通信, 那就不要发生直接联系;常见做法是引入第三者承担对象间通信作用;

## 17. 开放-封闭(OCP)原则
* 是面向对象程序设计中最重要的一条原则, 当需要改变一个程序的功能或者给这个程序增加新功能时，可以使用增加代码的方式但不允许改动程序的源代码；
* 过多的条件分支语句是造成程序违反开放-封闭原则的一个常见原因, 应第一时间考虑能否利用对象的多态性来重构;
* 发布订阅模式, 模板方法模式, 策略模式, 代理模式, 职责链模式都可以在一定程度上使得程序更加遵守开闭原则;
* 挑选最容易发生变化的地方然后构造抽象来封闭这些变化; 如果不能避免发生修改尽量修改更容易修改的地方
* 接受愚弄: 最初编写代码可以假设变化永远不会发生, 有利于迅速完成需求, 当变化发生并对接下来的工作造成影响的时候, 进行封装;

## 18. 接口和面向接口编程
* 接口是对象能响应的请求的集合;
* 抽象类, interface对面向接口 - 面向抽象编程的使用
* js动态语言，天然向上转型; 接口在js中更多的是代码检查, 使用部分防御性的代码防止类型错误;
* 用鸭子类型进行接口检查;

## 19. 代码重构
* 对超大函数的提炼: 易于复用/便于覆写/天然带有注释功能;
* 重复条件合并: 某些反复执行, 或在同一情况下反复出现的条件, 合并或提取;
* 将条件分支语句提炼成函数, 或更易读的配置; => 可读性增强, 维护性增强
* 合理使用循环;
* 提前让函数退出, 代替嵌套的条件分支;
* 传递对象参数代替过长的参数列表, 尽量减少函数参数的数量;
* 少用三目运算, 尤其是嵌套的三目运算;
* 合理使用链式调用;
* 分解大型类
* 用return退出多重循环;

## 视频课程补充01: - 工厂模式
* 定义一个用于创建对象的接口, 接口由子类决定实例化哪一个类; 该模式使一个类的实例化延迟到子类; 子类可以重写接口方法以便创建的时候制定自己的对象类型;
* echarts的绘制其实就是工厂模式的应用~(option的各个设定, 覆盖默认值, 自动输出的不同图形及其自带的各种接口交互)
* 对象构建复杂, 不同环境创建不同实例, 处理大量具有相同属性的小对象 => 使用工厂模式
* 工厂模式会增加代码的复杂度 -> 不可滥用;

## 视频课程补充02: - 适配器模式 - 同上面的14;
* 将一个类的接口转化成客户希望的另一个接口, 使原本接口不兼容不能一起工作的类可以一起工作(类/对象, 接口/属性/方法);
* 作用: 不符合要求的对象, 进行转化进而保证其可用性;
* 代理模式: 原接口符合使用在不改变原接口的条件下进行额外的代理, 适配器模式: 原接口不符合当前使用规范;
* 
## 视频课程补充03: - 迭代模式 - 同以上4;
* 顺序访问各个元素, 又不暴露内部表示; jquery-each;
* 给不同的集合提供统一接口, 支持同样的算法在不同的集合结构进行操作;
* 一般的迭代至少有2个方法, hasNext, next, 遍历所有对象; 遍历的同时更改迭代器集合结构可能会导致问题;









