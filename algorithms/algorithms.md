


# 1. 数据结构
* 列表: 元素不是很多, 不需要很长序列查找元素或者排序, 列表是一种最自然的数据组织方式; => 一组有序的数据,每个列表中的数据项称为元素; 元素数量受内存控制;
* 栈: 特殊的列表-高效的数据结构, 只能在栈顶删除或增加(后入先出): 进栈, 出栈; => 回文算法;
* 队列: 特殊的列表-队尾插入队首删除(先入先出); 特殊的-优先队列(某些条件优先出队-优先级出队); => 方块舞的舞伴分配问题
* 链表: js中数组效率低-链表其插入/删除/查找效率高可替代使用; 一系列节点(node)组成的集合, 每个节点都记录其后节点的引用(next), 头节点head;
* 字典: 键-值对形势存储; Object就是以字典形式设计的;
* 散列: 一种存储技术(快速插入取用) => 在散列表上插入/删除/取用数据非常快, 但查找(最大值最小值)效率低下; js散列表基于数组设计-理想情况下散列函数会将每个键值映射为唯一的数组索引, 数组长度有限-更现实的策略是将键均匀分布;
  *********
    数组长度预设, 可以随时增加, 所有元素根据和该元素对应的键保存数组特定位置;
    即使使用高效散列函数依然存在两个键值相同的情况 => 称之为“碰撞”;
    数组的长度应为一个质数, 所有策略都基于碰撞
    开链法: 两个键保存位置一样。开辟第二数组, 也成第二个数组为链;
    线性探测法属于开放寻址散列, 查找散列位置如果当前位置没有继续寻找下一个位置.存储数据较大较合适(数组大小 >= 1.5 * 数据 开链法, 数组大小 >= 2 * 数据 线性探测法);
  *********
* 集合: 包含不同元素的数据结构; 无序, 不允许相同成员的存在;(空集, 交集, 并集, 子集, 补集);
* 二叉树: 非线性数据结构, 分层存储; 二叉树查找/添加/删除非常快; 不允许相同成员存在;
  *********
    边, 节点, 根节点, 子节点, 父节点, 叶子节点, 层, 深度, 左右节点,
    子节点不超过2个 => 二叉树;
    二叉树特性: 较小值放左, 较大值放右;
    遍历方式: 先序遍历, 后序遍历, 中序遍历;
    相关操作: 查找, 删除, 添加操作
  *********
* 图

# 2. 算法
* 排序算法: 冒泡, 选择, 插入, 希尔, 归并, 快排, 检索
* 高级算法
* 导论

# 3. 相关案例
* 最小硬币找零问题(贪心, 动态规划) 指定数值 兑换成指定如[25, 10, 5, 1]最小组合
* 背包问题(动态规划, 分数背包-贪心): 给定一个携带W的背包, 可携带一组物品: 价值假定1: 2kg, 3$; 2: 3kg 4$; 3: 4kg 5$; 计算装的总价值如何最大
* 最长公共子序列=> 两个字符串中最常的子序列(可以不连续);
* 矩阵链相乘: 找出一个矩阵连最佳的相乘方式

# 4. 部分算法题网址
* [Hacker Rank](https://www.hackerrank.com/)
* [Coder Byte](http://coderbyte.com/)
* [UVa Online Judge](http://uva.onlinejudge.org/)
* [Sphere Online Judge](http://www.spoj.com)