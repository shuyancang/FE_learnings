<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // webpack 如果使用hash命名, 是否每次都会重新生成hash, webpack有哪些hash策略

    /*
      1. webpack的hash分类
        输出全部使用hash: 每个文件有相同的hash, 如果项目不变则hash不变如果变化则所有文件都会使用新hash
        输出全部使用chunkhash：chunkhash是根据不同入口进行依赖解析，构建chunk生成hash，从使用上可以吧一些公用库和程序入口单独打包构建，只要不改变入口代码其hash就不受影响，这样有缓存的作用；
        输出结果使用contenthash：每个文件有唯一hash，根据文件内容计算得到。要构建的文件内容发生变化就会生成新hash, 且该文件的改变不会影响同一模块下的其他文件。

        总结: 不是每次都会重新生成新的hash, 具体看使用策略。
          hash: 只要有文件更改, 全部文件的相同hash都会变化；(粒度：整个项目)
          chunkhash: 根据不同入口进行依赖解析，对应chunk生成hash，chunk的变化会影响hash的变化（粒度：entry入口）
          contenthash: 根据文件生成hash, 文件变化，生成hash。(粒度: 每个文件内容)

    
    
    */

    // webpack
    /*
      本质只是一个js引用程序的静态打包器, 能够基于文件依赖递归构建文件依赖关系图，最终将文件打包成为一个或多个bundle
      基于entry识别入口
      基于output将文件输出到指定的目录
      从入口出发，调用所有配置的loader对模块进行翻译，在找出模块依赖的模块，递归执行直到所有入口依赖的文件都经过了该步骤的处理。
      经过loader翻译完所有模块后，得到每个模块内容和依赖的关系，根据入口和模块的依赖关系主创陈一个包含多个模块的chunk再把每个chunk转换成单独的文件。
    
    
    */
  </script>
</body>
</html>