<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>

    // 1. 
      const str1 = 'abc'; // 基本类型 => 字符串字面量
      const str2 = new String('abc'); // 新建对象, 类型引用
      str1 == str2; // true
      str2 === str1; // false
      str1.substr(); // 'abc'
      str2.substr(); // 'abc'


    // 2. 
      var a = 1 + "2";
      var b = 1 - "2";
      var c = [1, 2] + [3, 4];
      console.log(a); // '12'
      console.log(b); // -1
      console.log(c); // '1,23,4' 非数相加会转换为字符串.


    // 3. 
      var x = 20;
      function a(y){
        var x = 10;
        return get(y);
      }

      function get(y){
        return x + y;
      }

      console.log(a(10)) // 30
      // 函数可读取全局变量, 函数外无法读取函数内的局部变量, 因此get方法中获取的是外部的x20

      // 4. 
        console.log(a);
        var a = 1;
        console.log(b);
        let b = 2;
        console.log(c);
        function c(){}
        // undefined, error, function c(){}(因为第二个b无法输出报错, 后续代码不再执行)
        // 最终结果 undefined, error(b is not defined)

        // 变量提升中，是函数优先, 其次才是变量声明, 函数在最顶部。
        // 变量声明, var提升, 初始设置为undefined, let, const变量并不进行初始化(词法绑定)
        // 变量声名提升规则:
        // 1. var 和 函数声明可以提升, 函数声明优先于var
        // 2. var 变量提升赋值undefined, 函数整体提升
        // 3. 函数声明重复声明会被覆盖
        // let 和 const
        // 1. 不存在变量声明提升，不能重复声明
        // 2. 作用域死区, 使用前必须先声明
        // 3. const声明, 如果值类型不可修改, 引用类型不可修改地址

      // 5. 
        Function.prototype.a = () => alert(1);
        Object.prototype.b = () => alert(2);
        function A(){}
        var a = new A(); // a显然是一个对象, 
        a.b(); // 所有对象, 必定是基于Object的实例, 因此有原型方法;
        a.a(); // a是对象, 不是函数, 不具备a方法, 报错(not a function)

      // 6. 
        function F(){
          this.a = 1;
        } 
        var obj = new F();
        console.log(obj.prototype) // undefined, 构造函数的实例, 没有prototype属性, 除了Function; 实例对象通过__proto__指向原型链

      // 7. 
        let a = 1, b = 2, head = { next: { next: 1 }};
        [a, b] = [b, a];
        [head.next, head.next.next] = [head.next.next, head.next];

        console.log(a, b, head);
        // a, b值互换，显而易见, a变为2, b变为1;
        // 初始head.next.next值为1缓存, head.next值为{next: 1}缓存起来, 
        // head.next = 1; head.next.next = {next: 1}显然, head变为{next: 1}(因为1.next = 1不符合要求)
        // 解构: 以上实际上可以理解为，在右边创建临时变量存储, 对应值然后赋值给等号左边的信息；

        /* 解构： 数组解构, 对象解构
          数组解构: 按顺序作用到数组的元素上, 变量或者对象的属性，取决于对应的位置；
            [, , c] = [1, 2, 3]可以有选择性的给对应位置赋值，省去不必要的赋值
          对象解构: 根据属性名解构，先找到同名属性, 把等号右侧的属性值赋值给等号左边的同属姓名的属性上。

          默认值, 如果数组解构中对应指定位置不存在, 就会使用默认值, 只要与undefined比较即可进行判定
        */
      
      // 8. 
        const value = {number: 10};
        let number = 2;
        const myultiply = (x = {...value}, y = number) => {
          y++;
          console.log((x.number *= y));
        }
        
        myultiply(); // 10 * 3 -> 30
        myultiply(); // 10 * 3 -> 30
        myultiply(value, number); // 10 * 3 -> 30但此时value为number:30
        myultiply(value, number); // 30 * 3 -> 90
        // {...value}为默认值时，为浅拷贝, 值不会被影响。
        // js中所有函数的参数, 都是按值传递的。把函数外部的值复制给函数内部的参数, 就合把值从一个变量复制到另一个变量一样。
        // 不过，基本类型的传递如同基本变量的复制一样，传递按值传递。而应用类型的传递如同引用类型变量的复制一样，是按照引用传递的。即，传入函数的是原始值的地址，因此在函数内部修改引用类型的值，会影响原始值。
      
      // 9. 
        const person = {name: 'zhangsan'}
        Object.defineProperty(person, "age", {
          value: 21
        });
        person.age = 18;
        console.log(person); // {name: 'zhangsan', 'age': 21}
        console.log(Object.keys(person));  // ['name']

        // Object.defineProperty方法添加的属性，默认不可枚举, 默认不可变, 不可改。
        // 对象里目前存在的属性描述符有两种主要形式: 数据描述符(value, writable)和存取描述符(getter, setter)
        // configurable: 是否可配置，可删除。
        // enumrable: 是否可迭代。
        // 如果描述符中属性被省略，默认configurable, enumrable, writable均为false, value, get, set均为undefined
  </script>
</body>
</html>