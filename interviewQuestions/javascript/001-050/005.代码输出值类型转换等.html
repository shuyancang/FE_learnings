<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>

    // 1. 
      const str1 = 'abc'; // 基本类型 => 字符串字面量
      const str2 = new String('abc'); // 新建对象, 类型引用
      str1 == str2; // true
      str2 === str1; // false
      str1.substr(); // 'abc'
      str2.substr(); // 'abc'


    // 2. 
      var a = 1 + "2";
      var b = 1 - "2";
      var c = [1, 2] + [3, 4];
      console.log(a); // '12'
      console.log(b); // -1
      console.log(c); // '1,23,4' 非数相加会转换为字符串.


    // 3. 
      var x = 20;
      function a(y){
        var x = 10;
        return get(y);
      }

      function get(y){
        return x + y;
      }

      console.log(a(10)) // 30
      // 函数可读取全局变量, 函数外无法读取函数内的局部变量, 因此get方法中获取的是外部的x20

      // 4. 
        console.log(a);
        var a = 1;
        console.log(b);
        let b = 2;
        console.log(c);
        function c(){}
        // undefined, error, function c(){}(因为第二个b无法输出报错, 后续代码不再执行)
        // 最终结果 undefined, error(b is not defined)

        // 变量提升中，是函数优先, 其次才是变量声明, 函数在最顶部。
        // 变量声明, var提升, 初始设置为undefined, let, const变量并不进行初始化(词法绑定)
        // 变量声名提升规则:
        // 1. var 和 函数声明可以提升, 函数声明优先于var
        // 2. var 变量提升赋值undefined, 函数整体提升
        // 3. 函数声明重复声明会被覆盖
        // 4. 在块(if true {} 或 if false {})内的函数声明 或 变量声明, 会将函数声明提升到函数作用域顶部;
        // 注意 
          // 如果改变了作用域内函数域声明的函数处理规则, 对老代码会产生影响, 因为为了减轻不兼容问题, es6在附录中规定浏览器可以不遵守以上规则有自己的定义方式
          // 允许在块级作用域内声明函数
          // 函数声明类似于var，会提升到全局作用域的头部
          // 同时, 函数声明还会提升到所在块级作用域的头部;
          // 以上三条规则只对ES6浏览器有效, 其他环境不一定遵守. 还是将块级作用域的函数当成let处理
          // 块级作用域函数, 就像预先在全局作用域中使用var声明一个变量, 且默认为undefined
        // 5. 块级作用域函数, 编译阶段将函数声明提升到全局作用域, 并声明一个变量, 同时会提升到块级作用域的顶部
        // 6. 块级作用域函数只有在定义声明函数那行代码执行过后，才会被映射到全局作用域;

        // let 和 const
        // 1. 不存在变量声明提升，不能重复声明
        // 2. 作用域死区, 使用前必须先声明
        // 3. const声明, 如果值类型不可修改, 引用类型不可修改地址

      // 5. 
        Function.prototype.a = () => alert(1);
        Object.prototype.b = () => alert(2);
        function A(){}
        var a = new A(); // a显然是一个对象, 
        a.b(); // 所有对象, 必定是基于Object的实例, 因此有原型方法;
        a.a(); // a是对象, 不是函数, 不具备a方法, 报错(not a function)

      // 6. 
        function F(){
          this.a = 1;
        } 
        var obj = new F();
        console.log(obj.prototype) // undefined, 构造函数的实例, 没有prototype属性, 除了Function; 实例对象通过__proto__指向原型链

      // 7. 
        let a = 1, b = 2, head = { next: { next: 1 }};
        [a, b] = [b, a];
        [head.next, head.next.next] = [head.next.next, head.next];

        console.log(a, b, head);
        // a, b值互换，显而易见, a变为2, b变为1;
        // 初始head.next.next值为1缓存, head.next值为{next: 1}缓存起来, 
        // head.next = 1; head.next.next = {next: 1}显然, head变为{next: 1}(因为1.next = 1不符合要求)
        // 解构: 以上实际上可以理解为，在右边创建临时变量存储, 对应值然后赋值给等号左边的信息；

        /* 解构： 数组解构, 对象解构
          数组解构: 按顺序作用到数组的元素上, 变量或者对象的属性，取决于对应的位置；
            [, , c] = [1, 2, 3]可以有选择性的给对应位置赋值，省去不必要的赋值
          对象解构: 根据属性名解构，先找到同名属性, 把等号右侧的属性值赋值给等号左边的同属姓名的属性上。

          默认值, 如果数组解构中对应指定位置不存在, 就会使用默认值, 只要与undefined比较即可进行判定
        */
      
      // 8. 
        const value = {number: 10};
        let number = 2;
        const myultiply = (x = {...value}, y = number) => {
          y++;
          console.log((x.number *= y));
        }
        
        myultiply(); // 10 * 3 -> 30
        myultiply(); // 10 * 3 -> 30
        myultiply(value, number); // 10 * 3 -> 30但此时value为number:30
        myultiply(value, number); // 30 * 3 -> 90
        // {...value}为默认值时，为浅拷贝, 值不会被影响。
        // js中所有函数的参数, 都是按值传递的。把函数外部的值复制给函数内部的参数, 就合把值从一个变量复制到另一个变量一样。
        // 不过，基本类型的传递如同基本变量的复制一样，传递按值传递。而应用类型的传递如同引用类型变量的复制一样，是按照引用传递的。即，传入函数的是原始值的地址，因此在函数内部修改引用类型的值，会影响原始值。
      
      // 9. 
        const person = {name: 'zhangsan'}
        Object.defineProperty(person, "age", {
          value: 21
        });
        person.age = 18;
        console.log(person); // {name: 'zhangsan', 'age': 21}
        console.log(Object.keys(person));  // ['name']

        // Object.defineProperty方法添加的属性，默认不可枚举, 默认不可变, 不可改。
        // 对象里目前存在的属性描述符有两种主要形式: 数据描述符(value, writable)和存取描述符(getter, setter)
        // configurable: 是否可配置，可删除。
        // enumrable: 是否可迭代。
        // 如果描述符中属性被省略，默认configurable, enumrable, writable均为false, value, get, set均为undefined
      
      // 10.
        const firstPromise = new Promise((res, rej) => {
          setTimeout(res, 500, 'one');
        });
        const secendPromise = new Promise((res, rej) => {
          setTimeout(res, 100, 'two');
        })
        Promise.race([firstPromise, secendPromise]).then(res => console.log(res));
        // 'two'， race处理的是率先改变状态的Promise， 因此只执行快速的。

      // 11. 
        function yideng(){
          console.log(1);
        }
        (function(){
          if(false){
            function yideng(){
              console.log(2);
            }
          }
          console.log(typeof yideng);
          yideng();
        })
        // undefined, TypeError: yideng is not a function
        // 直接在函数体内定义的函数声明, 整个都会提前, 但在块中声明的函数, 只会提升其声明部分, 不分配实际内存空间, 因此在上题内部yideng被提升的只是声明的函数名称变量, 未实际赋值。
      
      // 12. 
      console.log(a,window.a); // undefined undefined
      {
          console.log(a,window.a); // function a(){} undefined
          function a(){}
          console.log(a,window.a); // function a(){} function a(){}
      }
      console.log(a,window.a);	// function a(){} function a(){}

      // 13.
      console.log(window.a,a);//undefined undefined
      {
          console.log(window.a,a);//undefined function a(){}
          function a() {};
          a = 10;
          console.log(window.a,a); //function a(){}  10
      };
      console.log(window.a,a); //function a(){}  function a(){}
      // 第一个log,块级作用域函数a的声明会被提升到全局作用域，所以不报错，是 undefined undefined
      // 第二个log,在块级作用域中，由于声明函数a提升到块级作用域顶端,所以打印 a = function a(){}，而 window.a由于并没有执行函数定义的那一行代码，所以仍然为 undefined。
      // 第三个log,这时已经执行了声明函数定义，所以会把函数a映射到全局作用域中。所以输出 function a(){},
      // 第四个log,就是 function a(){} function a(){}，因为在块级作用域中壒壧攁厴婩壒.a的值已经被改变了，变成了function a(){}
      // 块级作用域函数只有执行函数声明语句的时候，才会重写对应的全局作用域上的同名变量

      // 14. 
      console.log("start");
      setTimeout(() => {
        console.log("children2");
        Promise.resolve().then(() => {
          console.log("children3");
        });
      }, 0);
      new Promise(function (resolve, reject) {
        console.log("children4");
        setTimeout(function () {
          console.log("children5");
          resolve("children6");
        }, 0);
      }).then((res) => {
        console.log("children7");
        setTimeout(() => {
          console.log(res);
        }, 0);
      });
      // start => children4 => children2 => children3 => children5 => children7 => children6
      // 先执行script宏任务脚本, 输出start; 第一个定时器进入宏任务队列, 
      // 执行微任务Promise, 输出children4; 第二个定时器进入宏任务队列；
      // 取出第一个定时器, 执行children2, 遇到微任务输出children3
      // 取出第二个定时器, 执行children5, 然后继续执行微任务, then 输出children7, 获取res输出children6
  </script>
</body>
</html>