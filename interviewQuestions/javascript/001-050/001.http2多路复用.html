<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // http2: 多路复用

    /*
      1. http1.1, 发起请求的流程: 浏览器请求url -> 域名解析 -> 建立http连接 -> 服务器处理文件 -> 返回数据 -> 浏览器解析渲染

      2. http1.1每次请求都需要建立http连接, 这个过程占用了相当长的时间, 除了第一次以外其他的都是非必须的。效率较低

      3. http1.1提供了keep-alive允许我们建立一次http连接返回多次请求数据，但依然有两个问题
        a. 基于串行文件传输数据, 因此请求需要有序, 所以alive只是节省了建立连接的时间，获取数据的时间并没有减少
        b. 最大并发数没有优化。浏览器本身限制最大请求数(chrome为6), 服务器能承载的最高并发数并不会有改进

      4. http2 引入二进制数据帧和流的概念, 并采用二进制格式传输
        a. 其中帧对数据进行顺序标识，这样浏览器收到数据后可以按照序列对数据进行合并，而不会出现错乱。进而可以并行的传输数据。
        b. http2对同一域名下所有请求基于流，即统一域名无论访问多少文件，也只建立一路链接。因此最大并发数的到了提升
        c. 采用二进制格式传输取代1.x的文本格式
      
      多路复用代替了http1.x的序列和阻塞机制，所有相同域名的请求都通过同一个tcp连接并发完成。在http1.x中并发多个请求需要多个tcp连接。浏览器为了控制资源有多个tcp连接。

      http2:
        同域名下所有通信在单个连接完成，消除多个tcp连接带来的延时和内存消耗
        单个连接上可以并行交错的请求和响应，互不干扰。

      队首阻塞: 一列的第一个数据包(队头)受阻而导致整列数据包受阻。
      多路复用: 并行交错的发送多个请求和响应, 互不干扰。多路复用代理原来的序列和阻塞机制。所有请求都是通过一个TCP链接并发完成。因为在多路复用之前所有传输都是基于基础文本的，在多路复用中是基于二进制帧的传输。所以可以做到乱序的传输。多路复用对同一域名下所有请求都是基于流，因此不存在同域名并行的阻塞。



    */






  </script>
</body>
</html>