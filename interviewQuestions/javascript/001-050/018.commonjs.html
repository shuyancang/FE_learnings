<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 谈一谈commonjs的实现愿意

    /*
      1. 模块化
        1.1 最初的模块化需要使用命名空间(jq的window.$), 会导致命名空间冲突, 无法合理管理版本和依赖, 无法控制依赖的加载顺序等问题;
        1.2 模块化开发: 提升效率, 方便维护, 方便重用;
        1.3 从生产角度, 模块化开发是一种生产方式, 效率高成本低; 软件角度说是一种开发模式, 便于维护开发效率高
        1.4 模块化规范: 服务端主要是commonjs, 主要有AMD(异步模块定义, 依赖前置), CMD(通用模块定义, 依赖就近). AMD规范主要有requirejs，cmd主要实现有seajs, 随着es6已有模块化的实现, 第三方模块化组件淘汰
      
      2. commonjs
        作为nodejs的规范, 现阶段require/exports依然必须(与ES6的差异, 暂时无法直接兼容); 
        babel可将未被宿主环境直接支持的ES6 module编译为ES5的commjs, 
        commonjs的核心: 通过require来同步加载依赖, 通过module.exports导出需要暴露的接口（module.exports = someModule; const moduleA = require('someModule')）
      
      3. 当node遇到require(X)时, require内部逻辑: 
        3.1 X为内部模块时: 直接返回该模块
        3.2 以相对路径开头: 找到当前所在模块位置找到X的路径, 找到对应的引入(可以是程序, 文件, 或目录)
        3.3 如果X带路径, 根据所在位置，确定X可能的安装目录, 或在每个目录中查找
        3.4 如果以上都没找到, 抛出not fount异常
        3.5 找到对应引入后, node内部提供一个Module函数, 所有模块都是Module的实例, require的源码在Node的lib/module.js文件中, 
          function Module(id, parent){
            this.id = id; // 识别符, 通常是带有绝对路径的模块文件名
            this.exports = {}; // 模块的对外输出
            this.parent = parent; // 调用该模块的模块
            this.filename = null; // 模块文件名, 带有绝对路径
            this.loaded = false; // 加载状态
            this.childen = []; // 模块要使用的其他模块
          }
          module.exports = Module;
          基于该方式, 定义了模块的导出
        3.6 加载模块: 
          Module.prototype.load = function(filename){
            var extension = path.extname(filename) || 'js';
            Module._extensions[extension](this, filename);
            this.loaded = true;
          }
          // 再基于js, json进行不同的处理
          Module._extensions['.js'] = function(module, filename){
            const content = fs.readFileSync(filename, 'utf8');
            module._compile(stripBOM(content), filename);
          }
           Module._extensions['.json'] = function(module, filename){
            const content = fs.readFileSync(filename, 'utf8');
            try{
              module.exports = JSON.parse(stripBOM(content));
            }catch(err){}
          }
          // module_compile用于模块的编译:
          Module.prototype._compile = function(content, filename){
            var self = this;
            var args = [self.exports, require, self, filename, dirname];
            return compiledWrapper.apply(self.exports, args);
          }
          基本等同于: function(exports, require, module, __filename, __dirname){}
      
      总结: 
          commonjs核心: 注入exports, require, module三个全局变量, 执行模块的源码, 然后将模块exports变量值输出
    */ 

  </script>
</body>
</html>