<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // js的垃圾回收机制是什么, 常用的是那种, 怎么处理。

    /*
      v8的新老空间内存分配与大小限制:

      1. 新老空间: 
        没有一种特定的垃圾回收机制可以完美解决问题;
        v8才去的是新生代老生代结合的垃圾回收机制, 内存分为新生代 + 老生代。

        新生代: 频繁GC, 空间小, 采用空间换时间的scavegne算法。划分为semispace, From和To
        老生代: 保存存活时间较长或较大对象，采用mark-sweep主 mak-compact辅算法

        v8限制js对象可使用的内存空间, 不只是因为v8最初为浏览器引擎设计, 还有其垃圾回收机制的影响因素
        v8使用stop-the-world全停顿, generational accurate的垃圾回收器, 在自行回收时会暂停中断程序的执行, 而且只处理对象堆栈。

        当内存达到一定体积时, 一次垃圾回收时间很长, 从而会造成浏览器假死状态, 因此v8限制新生代64位为1.4G,32位0.7G, 新生代64位32M, 32位16M.(可以在node中更改需要的更大内存空间)
      
      2. 对象晋升:
        大部分老生代对象由新生代晋升而来；
        晋升方式1-溢出的对象: 新生代的To semispace占满25%时, 此时再从From semispace拷贝对象将不再放入To空间以防影响后续新对象的分配, 而将其直接复制到老生代中。
        晋升方式2-经历过GC: 进行一次垃圾回收后第二次GC时, 发现已经经历过一次GCd的对象从From空间直接复制到老生代;
        晋升方式3-过大的对象: 当分配到新生代From semispace的对象体积过大(超出1M), 直接分给到老生代的large Object Space中
      3. 新生代的GC机制:
        新对象分配到新生代的From semispace-处于使用状态；
        垃圾回收检查From空间的存活对象， 将其复制到闲置的To空间, 回收其他对象。完成复制后进行紧缩;
        From空间现在闲置, To空间保存新活动对象, 交换两者空间。如此循环往复。
        
        优势：在新生代垃圾回收中, 总有一半semispace是空余的，scavenge只复制存活的对象, 在新生代内存中, 存活对象相对较少, 所以该算法恰到好处。

      4. 老生代的GC机制:
        犹豫scavenge值复制存活的对象, 如果老生代也是用该方法会复制很多对象, 效率低且造成内存空间浪费, 因此老生代使用的是mark-sweep(标记清除)和mark-compact(标记整理)结合的方式。

        mark-sweep标记清除: 
          标记堆内存的所有对象, 标记出在使用的对象, 清除那些没有被标记的对象。
          在老生代中, 不使用的对象只占小部分, 因此清除不使用的效率更高。
          mark-sweep不会讲内存空间分两半, 不会浪费一半空间.

          但缺点在于, 在清楚后导致内存不连续，造成内存碎片。如果需要存储大内存而空间不够时，就会导致反复的垃圾回收；=> 需要标记整理的协助
        
        mark-compact标记整理
          将存活的对象和需要清除的对象移动到两端，将需要清除的回收，可以解决内存碎片问题
          缺点：整理过程中，移动对象效率较低，因此主要使用标记清除，在空间不足是对新生代晋升过来的对象进行分配时才使用标记整理。

      5. 垃圾回收机制的优化：
        增量标记(在老生代引入此方式)
        scavenge算法, mark-sweep, mark-compact都会导致全停顿, 从而导致程序迟滞, 标记阶段很容易超过100ms;
        因此v8引入增量标记, 将标记阶段分若干小步骤, 每个步骤5ms, 没运行一段时间标记, 就让js程序执行, 如此交替提升程序流畅性, 避免卡顿。
    
    
    */

    /*
      引用计数法(reference counting): 
        跟踪记录值被引用次数; 
        当声明变量并将一个引用类型的值复制给该变量时引用次数+1; 
        同一值赋予另一变量, 引用次数+1;
        引用值的变量被别的值取代, 引用次数 -1;
        计数为0, 回收;
        缺点: 循环引用时, 不会被释放;
      
      标记清除(mark-sweep): 内存变量加上标记, 没有被引用的变量进行清除
      
      停止复制(stop-copy): 内存分两块, 正在使用的存活对象复制到未被使用的内存块中, 清除正在使用内存块中所有对象, 交换内存角色

      标记压缩(mark-compact)： 所有可达对象做一次标记, 将存活对象压缩到内存的一段。

      增量算法(incremental collecting): 每次GC线程只手机一小片内存空间, 接着切换到引用程序线程, 一次反复, 直到垃圾回收完成。
    
      栈的数据GC: 有一个记录当前指向状态的指针(esp), js引擎通过下移esp指针销毁栈顶的某个执行上下文, 释放栈空间。
    */
  </script>
</body>
</html>