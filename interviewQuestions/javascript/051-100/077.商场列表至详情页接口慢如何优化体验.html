<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 商场列表页跳转到详情页, 详情数据接口很慢, 前端可以如何优化;

    /* 基本的优化简介
      1. 懒加载: 图片地址不直接放在src, 而是放到其他(data-original)属性中
      2. 利用骨架屏提升体验
      3. Preload预加载(使用html及XHR的加载), 提供了对进度和完成事件的良好支持。
      4. 添加前端loading
      5. 添加超时404的友好页面
      6. 接口部分可以进行部分接口的缓存 和 预加载：
        workbox对数据进行缓存, 缓存优先
        orm对本地离线数据进行缓存, 优先请求本地
        采用预加载, 进入详情页阶段使用quicklink预加载详情页
        使用nodejs作为中间层将详情数据缓存到redis等
    */

    /* 详细优化
      1. 一个页面开始出现可见元素, 首次绘制内容(FCP)(FC: 首次绘制), 标志用户体验视觉开始, 到TTI(可交互时间)可交互元素出现, 标识交互体验开始。因此尽量缩短到达TCP和TTI的时间。
      2. 页面数据缓存
        第一次进入页面, 可用骨架图进行模拟FC展示, 骨架图可使用背景图行内的方式对首次进入详情页进行展示, 对于请求缓慢的接口使用worker进程, 对详情接口请求在另一个线程中处理。页面渲染其他返回数据的元素; 当缓慢的数据回来后需对页面根据商品id签名为key 进行webp或缩略图商品图的cnd路径localStorage缓存, 商品id签名放在cookie中并设置成httpOnly

        非第一次进入页面, 通过特定的接口请求回来对应的商品id, 签名cookie读取localStorage中的缓存数据, 这样可以快速缩短时间，再进行worker数据进行高清图片的切换。
      3. 过期缓存数据的处理(后端控制为主, LRU为辅)
        缓存图片地址的处理, (localStoraget不限制大小但不应太多, 使用lru算法进行清理, 超过七天的数据清理详情数据)
      4. 数据缓存和过期缓存数据
      5. 对于大请求量的请求(猜你喜欢, 推荐商品等大数据量的静态资源)
        由于不属于用户进入详情第一时间需要获取, 不属于当前页面主题, 可食用Intersection Observer在主体元素被加载后, 再进行资源分配。
        需要保证当前详情页请求列表的请求数不超过当前浏览器请求一个tcp的最大http请求数
      6. worker数据返回后, 出现大量图片替换对应元素的webp或缩略图出现的问题
        移动端: 懒加载, (intersection oberserver 或 vue-lazy等)
        pc端: img出现一张, load一张; 防止在替换过程中, 用户快速滑动到后面。
      7. 页面的重绘重排
        尽量减少产生重绘重排的操作。多个图片同时加载时, 可批量获取所有src标签后, 进行重绘。
      8. css代码处理: 注意被阻塞的css资源。减少不同页面的css代码加载(某些特定情况下的css代码, 可以过滤)
        一些需要css媒体查询的网站, 最好写两套css代码, 通过link媒体查询动态加载, 可以减轻网站加载css的压力
      9. 静态js处理
        关于埋点, 本地日记, 动态修改css代码, 读取页面成型后信息的一些js, 一律放在同域下的localStorage
      10. 容错
        页面获取workder回来数据后, 通过拷贝html片段, 再将img路径替换对应img资源后, 再进行追加
        缓存css文件和js文件, 如果没有对应的文件, 或被恶意修改过的(可使用签名判断), 删除再更新
      11. 推荐方案理由
        worker不占用主线程, 减少主进程消耗在网络的时间
        localStorage缓存, 因为worker后读取localStorage是同步不会有太大等待时间, 使用后端返回的cookieId进行读取(httpOnly)能避免第三方获取到cookieId进行商品信息读取
        LRU清除过多的缓存数据
        首次进入页面时, 保证已知页面布局的情况下快速渲染及配置骨架屏, 加快打到FCP和FP时间
        就算img资源过大, 第二次进入页面, 也可做到低次数的重绘重排, 加快到达TTI的时间
      12. 不足
        在网络依然很慢的情况下, 首次进入详情页面, 如果长时间的骨架屏体验依旧不好, 可考虑PWA方案, 对最近一次成功请求的内容进行劫持, 在无网环境做出相应提示和展示
        UI需要提供三套静态img资源
    */
  </script>
</body>
</html>