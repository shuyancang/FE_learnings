<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 描述一下js中的Scope, Closure, Prototype概念, 说说js的封装, 继承实现原理

    /*
      1. Scope-作用域
          变量和函数运行到某个地方的代码处, 能否被访问到;
          计算机科学中最基本的概念和理念: 隔离性;
          为了明确职责, 只能刚好访问到所需的所有东西, 不多不少, 附带的, 带来模块化, 命名空间等好处, 写出更易阅读更易维护的代码。可以说作用域是许多现代编程语言从语法层面支持的特性。
          词法作用域(lexical scope): 一个变量可以通过变量名引用而不发生应用错误。本质上, 是静态作用域。
      
        作用域的类型
          全局作用域: 不定义在任何函数以内的变量或函数, 都在全局作用域下.(其实也有边界/上下文, 如nodejs中不同文件的全局变量不互相访问, 因为每个全局对象中的global上下文仅限一个文件, 浏览器中不同tab中的全局变量也不能互相访问)
          
          函数作用域: 定义在函数内的变量或函数, 在函数作用域下, 无法被函数外引用
          
          块作用域: ES6后, 通过let和const关键字, 赋予一般的块block以块作用域.

          在函数或块作用域中生命的变量或函数发生嵌套, 又有了嵌套下的词法作用域规则. 相对的位于一个函数/块内的变量或函数, 称内层作用域, 前者相对的称为外层作用域(inner scope -  outer scope)

        作用域, 只需关注模块内的代码, 不需考虑其他。可以专注在当前代码片段, 降低负担. 符合单一职责原则(SRP), 提高开发和维护效率。
      
      3. Closure闭包: 一个函数返回一个函数的引用, 形成一个闭包
        闭包: 当函数能够记住并访问所在词法作用域, 即函数在词法作用域范围之外, 就产生了闭包。
        闭包可以读取其他函数内部变量的函数. 由于js中只有函数内部的子函数才能读取局部变量, 因此可以把闭包简单理解成"定义在函数内部的函数"。所以本质上闭包是将函数内部和函数外部关联的一个桥梁。
        从实现上讲，闭包是一条记录, 存储一个函数与其环境的上下文信息.

        闭包的作用: 使局部作用域歪能调用局部作用域内的变量。
    
      4. Prototype: 原型链
        prototype对象是面向对象的一个重要机制。每个函数都是一个对象，都有一个prototype属性
        类是以函数的形式来定义的. prototype标识函数的原型, 也表示一个类的成员的集合。

        原型: 
          每个函数内部都有prototype属性, 构造函数实例对象也有一个内部属性作为一个指针指向构造函数原型对象。所有实例共享原型对象上的属性和方法。
        
          原型是js语言的一个特征, 任何对象都有原型。函数对象有原型, 普通object也有原型。原型是一个object, 其本身也有原型, 这就构成了原型链。知道Object.prototype(null)

          读取对象某个属性时, js现寻找对象自身属性, 如果没有就去原型寻找, 知道最顶层的Object.prototype.

          如果对象自身和原型上都定义了同一个属性, 则优先读取自身的属性. 即覆盖。
      
      5. 封装: 把客观事物封装成抽象类。    
    */
  </script>
</body>
</html>