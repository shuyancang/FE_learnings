<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 描述一下js中的Scope, Closure, Prototype概念, 说说js的封装, 继承实现原理

    /*
      1. Scope-作用域
          变量和函数运行到某个地方的代码处, 能否被访问到;
          计算机科学中最基本的概念和理念: 隔离性;
          为了明确职责, 只能刚好访问到所需的所有东西, 不多不少, 附带的, 带来模块化, 命名空间等好处, 写出更易阅读更易维护的代码。可以说作用域是许多现代编程语言从语法层面支持的特性。
          词法作用域(lexical scope): 一个变量可以通过变量名引用而不发生应用错误。本质上, 是静态作用域。
      
        作用域的类型
          全局作用域: 不定义在任何函数以内的变量或函数, 都在全局作用域下.(其实也有边界/上下文, 如nodejs中不同文件的全局变量不互相访问, 因为每个全局对象中的global上下文仅限一个文件, 浏览器中不同tab中的全局变量也不能互相访问)
          
          函数作用域: 定义在函数内的变量或函数, 在函数作用域下, 无法被函数外引用
          
          块作用域: ES6后, 通过let和const关键字, 赋予一般的块block以块作用域.

          在函数或块作用域中生命的变量或函数发生嵌套, 又有了嵌套下的词法作用域规则. 相对的位于一个函数/块内的变量或函数, 称内层作用域, 前者相对的称为外层作用域(inner scope -  outer scope)

        作用域, 只需关注模块内的代码, 不需考虑其他。可以专注在当前代码片段, 降低负担. 符合单一职责原则(SRP), 提高开发和维护效率。
      
      3. Closure闭包: 一个函数返回一个函数的引用, 形成一个闭包
        闭包: 当函数能够记住并访问所在词法作用域, 即函数在词法作用域范围之外, 就产生了闭包。
        闭包可以读取其他函数内部变量的函数. 由于js中只有函数内部的子函数才能读取局部变量, 因此可以把闭包简单理解成"定义在函数内部的函数"。所以本质上闭包是将函数内部和函数外部关联的一个桥梁。
        从实现上讲，闭包是一条记录, 存储一个函数与其环境的上下文信息.

        闭包的作用: 使局部作用域歪能调用局部作用域内的变量。
    
      4. Prototype: 原型链
        prototype对象是面向对象的一个重要机制。每个函数都是一个对象，都有一个prototype属性
        类是以函数的形式来定义的. prototype标识函数的原型, 也表示一个类的成员的集合。

        原型: 
          每个函数内部都有prototype属性, 构造函数实例对象也有一个内部属性作为一个指针指向构造函数原型对象。所有实例共享原型对象上的属性和方法。
        
          原型是js语言的一个特征, 任何对象都有原型。函数对象有原型, 普通object也有原型。原型是一个object, 其本身也有原型, 这就构成了原型链。知道Object.prototype(null)

          读取对象某个属性时, js现寻找对象自身属性, 如果没有就去原型寻找, 知道最顶层的Object.prototype.

          如果对象自身和原型上都定义了同一个属性, 则优先读取自身的属性. 即覆盖。
      
      5. 封装: 把客观事物封装成抽象类, 类可以把自己的数据和方法让可信的类或对象操作.
        将用户不需要知道的数据和方法隐藏, 外部无法直接访问. js中可以使用闭包实现。
        es6以前, 构造函数创建一个类: this, prototype, ==> 原型链 的方式进行添加和声明
        es6: class关键字.
        属性和方法的封装: 
          私有属性(安全, 内部使用, 不暴露), 
          公有属性(可访问的内部属性), 
          私有方法(不暴露的内部方法), 
      6. 继承: 
        js只有一种结构: 对象。
        每个实例对象都有一个私有属性指向构造函数的原型对象。原型链层层向上直到null; 
        几乎所有js对象都是位于原型链顶端的Object的实例。

        6.1 基本概念: 一个对象想拥有被继承对象的方法属性。通过类的继承实现代码复用, 通过类的实例化来实现多个对象。
          js中的继承通过原型实现。
          如果不用原型, 通过new的实例不共享任何属性; 通过原型对象中定义的变量和方法被多个对象共享。 需要注意, 原型对象的属性并不是实例对象自身的属性, 只要修改原型对象, 变动会立刻体现在所有实例对象上。想法如果对象属性被修改，原型中相同属性并不会修改。
        6.2 实现原理:
          对于new Foo的调用(var o = new Foo()), 实际上js执行的是: 
            var o = new Object();
            o.prototype = Foo.prototype;
            Foo.call(o);
    */
    
    // 实现继承: B继承自A;
    function A(){}
    function B(){}
    B.prototype = Object.create(A.prototype);
    B.prototype.constructor = B;

    // Object.create原理
    Object.create = function(proto, propertiesObj) {
      function F(){};
      F.prototype = proto;
      return new F();
    }

    // 几种继承
    // 1. 原型链继承
    function 

  </script>
</body>
</html>