<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    /*
      实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
      如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。[9, 8, 7, 6, 5, 4, 3, 2, 1,]
      必须原地修改，只允许使用额外常数空间。
      以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
      1,2,3 → 1,3,2
      3,2,1 → 1,2,3
      1,1,5 → 1,5,1

      提示：
        1 <= nums.length <= 100
        0 <= nums[i] <= 100
    */
    var nextPermutation = function(nums) {
      /*
        差点没看懂题目····
        数组按顺序合并起来: [1, 2, 3]为123; 在[1, 2, 3]能组成的数中(213, 231, 132, 312...)刚刚好比123大的那个输出, 
        如果[3, 2 ,1]不存在比321更大的，输出最小的[1, 2, 3]
      */

      /*
        // 解法一: 
        // 1. 从后往前遍历, cur前面只要找到一个比他小的元素，即停止-此元素索引i-记为val(i);
        // 2. 从i 到 cur中, 一定有一个最小的大于i的数, 索引记为j; 记为val(j);
        // 3. 交换i和j;
        // 5. i后的数值, 进行降序排列;[3, 6, 9, 5, 2];
        // 6. 若未找到i, 反转数组;
        const len = nums.length;
        for(let i = len - 1; i > 0; i--){ // 最末开始遍历
          const cur = nums[i];
          let tmpMinIndex = i;
          for(let j = i - 1; j >= 0; j--){
            const pre = nums[j];
            if(cur > pre){ // 找到了要交换的点
              const tmp = nums[j];
              nums[j] = nums[tmpMinIndex];
              nums[tmpMinIndex] = tmp;
              for(let m = j + 1; m < len; m++){ // 将m后 到 i的项, 进行降序排列;
                // 排序略.
              }
            }
            if(nums[j] < nums[tmpMinIndex]){ // 过程中的最小值位置
              tmpMinIndex = j;
            }
          }
          if(cur > pre){ // 当前位置比前一个位置值大的，交换位置即可
            nums[i - 1] = cur;
            nums[i] = pre;
            return nums;
          }
        }
        for(let i = 0; i < len / 2; i++){ // 没有返回值, 需要反转数组
          const tmp = nums[i];
          nums[i] = nums[len - 1 - i];
          nums[len - 1 - i] = tmp;
        }
        return nums;
      */


    };

   /*
   

  function nextPermutation(nums) {
    let i = nums.length - 2;                   // 向左遍历，i从倒数第二开始是为了nums[i+1]要存在
    while (i >= 0 && nums[i] >= nums[i + 1]) { // 寻找第一个小于右邻居的数
        i--;
    }
    if (i >= 0) {                             // 这个数在数组中存在，从它身后挑一个数，和它换
        let j = nums.length - 1;                // 从最后一项，向左遍历
        while (j >= 0 && nums[j] <= nums[i]) {  // 寻找第一个小于 nums[i] 的数
            j--;
        }
        [nums[i], nums[j]] = [nums[j], nums[i]]; // 两数交换，实现变大
    }
    // 如果 i = -1，说明是递减排列，如 3 2 1，没有下一排列，直接翻转为最小排列：1 2 3
    let l = i + 1;           
    let r = nums.length - 1;
    while (l < r) {                            // i 右边的数进行翻转，使得变大的幅度小一些
        [nums[l], nums[r]] = [nums[r], nums[l]];
        l++;
        r--;
    }
  }

作者：xiao_ben_zhu
链接：https://leetcode-cn.com/problems/next-permutation/solution/jie-fa-hen-jian-dan-jie-shi-qi-lai-zen-yao-jiu-na-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


    解题思路
初始待交换位置为-1。倒序找第一个后 > 前位置，前为待交换位置
倒序找第一个> 待交换位置的位置，与待交换位置交换
从待交换位置 + 1和数组尾部，向中间，双指针交换
代码

var nextPermutation = function(nums) {
    let s = (l, r, t) => (t = nums[l], nums[l] = nums[r], nums[r] = t), l = -1, r = nums.length
    for(let i = r; i--;)
        if (nums[i] > nums[i - 1]) l = i - 1, i = 0
    if (l !== -1) 
        for(i = r; i-- > l;)
            if (nums[i] > nums[l]) s(i, l), i = 0
    while (++l < --r) s(l, r)
};
结果


完整思路
数组看成数
数怎样变大？
举例：数19，高位是十位1，低位是个位9
高位 < 低位，交换高位和低位成91，数变大
举例：数21，高位是十位2，低位是个位1
高位 > 低位，再交换成12，数变小
所以数变大，需找：
高位 < 低位，然后交换
倒序遍历数组，即从低位到高位遍历数。举例：[1, 4, 6, 5]
高位 < 低位，然后交换
6 > 5过，4 < 6交换，得[1, 6, 4, 5]
1645 > 1465新数变大了。如果不要求下一个排列，这样做即可
下一个排列怎么找？
回到例子[1, 4, 6, 5]
个位上的5比十位上的6更小，更适合与4交换
找4到数组尾部的最小值与4交换 更好
回想一下，4是怎样找到的呢？
倒序遍历数组，找高位 < 低位
这意味着4到数组尾部，都是高位 > 低位，是一个降序序列
数组末尾就是最小值
直接与数组末尾交换，行不行？
回到例子：4 < 5，交换，得[1, 5, 6, 4]，似乎可以
改下例子：[1, 4, 6, 3]，得[1, 3, 6, 4]，变小了
所以，除了4到数组尾部的最小值，还需这个数比4大
所以，找下一个排列：
倒序遍历数组，从最小值开始，找比4大的
好像还不对？
回到例子，交换4和5，得[1, 5, 6, 4]
十位+个位64，显然46更好
回想一下，4到数组尾部，都是高位 > 低位，是一个降序序列
数组看成数，降序序列最大。升序序列最小
双指针交换
从4开始（4 + 1）和数组尾部向中间交换，将降序序列变升序序列即可
如果本来就是降序序列，可声明左指针初始为-1，复用交换逻辑
   */ 
  </script>
</body>
</html>