<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    /*
      实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
      如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
      必须原地修改，只允许使用额外常数空间。
      以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
      1,2,3 → 1,3,2
      3,2,1 → 1,2,3
      1,1,5 → 1,5,1

      提示：
        1 <= nums.length <= 100
        0 <= nums[i] <= 100
    */
    var nextPermutation = function(nums) {
      /*
        差点没看懂题目····
        数组按顺序合并起来: [1, 2, 3]为123; 在[1, 2, 3]能组成的数中(213, 231, 132, 312...)刚刚好比123大的那个输出, 
        如果[3, 2 ,1]不存在比321更大的，输出最小的[1, 2, 3]
      */
      // 1. 从后往前遍历, 任意一个索引在后的数, 找到第一个大于索引在前的数, 交换位置 => result
      // 2. 若最终未找到 => 已是最大数 => reverse
      const len = nums.length;
      for(let i = len - 1; i > 0; i--){ // 最末开始遍历
        let cur = nums[i], pre = nums[i - 1];
        if(cur > pre){ // 只要任意找到一个当前位置比前一个位置值大的，交换位置即可
          nums[i - 1] = cur;
          nums[i] = pre;
          return nums;
        }
      }
      // 没有返回值, 需要反转数组
      for(let i = 0; i < len / 2; i++){
        const tmp = nums[i];
        nums[i] = nums[len - 1 - i];
        nums[len - 1 - i] = tmp;
      }
      return nums;
    };
  </script>
</body>
</html>