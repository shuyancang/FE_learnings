<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>相同树</title>
</head>
<body>
  <script>
    // 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
    // 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

    // 示例 1：
    //   输入：p = [1,2,3], q = [1,2,3]
    //   输出：true
    // 示例 2：
    //   输入：p = [1,2], q = [1,null,2]
    //   输出：false
    // 示例 3：
    //   输入：p = [1,2,1], q = [1,1,2]
    //   输出：false

    // 显然先序遍历是最优方法 ~ 但递归处理问题是真简单 => 深度优先
    var isSameTree = function(p, q) {
      if(p !== null && q !== null && p.val !== q.val){
        return false;
      } else if ((p !== null && q === null) || (q === null && p !== null)){
        return false;
      } else if (p === null && q === null){
        return true;
      }
      return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    };

    // // 广度遍历 => 需要额外的空间~算了。
    // var isSameTree = function(p, q) {
    //   if(p === null && q === null){
    //     return true;
    //   } else if (p === null || q === null) {
    //     return false;
    //   }
    //   let pQueue = [p], qQueue = [q]; // q, p必定存在
    //   for(let i = 0; i < pQueue.length; i++){
    //     const curP = pQueue[i], curQ = qQueue[i]; 
    //     if(curP === null && curQ === null){
    //       continue;
    //     } else if (curP === null || curQ === null) {
    //       return false;
    //     }
    //   }
    //   return true;
    // };
  </script>
</body>
</html>