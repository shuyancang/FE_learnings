<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>恢复二叉搜索树</title>
</head>
<body>
  <script>
    // 给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。
    // 进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？

    // 示例 1：
    //   输入：root = [1,3,null,null,2]
    //   输出：[3,1,null,null,2]
    //   解释：3 不能是 1 左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。

    // 示例 2：
    //   输入：root = [3,1,4,null,null,2]
    //   输出：[2,1,4,null,null,3]
    //   解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。

    // 提示：
    //   树上节点的数目在范围 [2, 1000] 内
    //   -231 <= Node.val <= 231 - 1

    // 第一想法中序遍历; 然后找到不合适的两个数字;
    var recoverTree = function(root) {
      let list = []; // 中序遍历集合
      // 分别找到两个数, 一个数大于左右, 一个数小于左右, 则就是这两个数, 交换回来即可。
      // 再次进行root遍历, 找到对应的两个节点, 分别进行处理即可 
    }

    // 第二想法: 中序遍历, 找到并记录两个异常root(大于前后或小于前后)对应的val(errValFir, errValSec); 再次中序遍历交换异常root即可;
    var recoverTree = function(root){
      
    }

    // leetcode解法: 对于一个升序数组如果有任意节点交换位置, 
  </script>
</body>
</html>