<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>不同的二叉搜索树</title>
</head>
<body>
  <script>
    // 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

    // 示例 1：
    //   输入：n = 3
    //   输出：5

    // 示例 2：
    //   输入：n = 1
    //   输出：1

    // 提示：1 <= n <= 19
    var numTrees = function(n) { // 第一想法就是递归~分别为以某个数为根节点的左右二叉树可能数量 再结合计算 === > 超时了。。。
      function binaryTool(start, end){
        let count = 0;
        if(start > end) {
          return 0;
        }
        for(let i = start; i <= end; i++){
          const leftCount = binaryTool(start, i - 1);  // 左树可能
          const rightCount = binaryTool(i + 1, end);  // 右树可能
          count += (leftCount === 0 ? 1 : leftCount) * (rightCount === 0 ? 1 : rightCount)
        }
        return count;
      }
      return binaryTool(1, n);
    };

    // 第二想法动态规划: f(m)(n)为从m => n(m < n)的数量, 则f(m)(n)~也要反复迭代不能直接出来啊~得斜着迭代且 要再次遍历叠加~
    
    // 第三基于第一种方法数学归纳即可显然f(n)只取决于n, 直接循环出结果; f(0) = 0, f(1) = 1
    var numTrees = function(n) {
      if(n === 0 || n === 1){
        return n;
      }
      let res = [1, 1];
      for(let i = 0; i < n; i++){
        let count = 0;
        // for(let mid = ){
          // count += 
        // }
      }
      // let res = [1]; // 差值为0(m = n = 1)的树只有一种
      // for(let i = 1; i <= n; i++){ // i指代差值, 最小是0, 最大差值可达n - 1;
      //   let count = 0;
      //   for(let mid = 0; mid <= i; mid++){
      //     count += res[mid] * res[i - mid];
      //   }
      //   res[i] = count;
      // }
      return res;
      // return res[n - 1];
    }




  </script>
</body>
</html>