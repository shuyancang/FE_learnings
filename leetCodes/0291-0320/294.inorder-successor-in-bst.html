<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>二叉搜索树的中序后继</title>
</head>
<body>
  <script>
    // 给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null 。
    // 节点 p 的后继是值比 p.val 大的节点中键值最小的节点。

    // 示例 1：输入：root = [2,1,3], p = 1           输出：2
    //   解释：这里 1 的中序后继是 2。请注意 p 和返回值都应是 TreeNode 类型。
    // 示例 2：
    //   输入：root = [5,3,6,2,4,null,null,1], p = 6 输出：null
    //   解释：因为给出的节点没有中序后继，所以答案就返回 null 了。
    //  
    // 提示：
    //   树中节点的数目在范围 [1, 104] 内。
    //   -105 <= Node.val <= 105
    //   树中各节点的值均保证唯一。

    var inorderSuccessor = function(root, p) { // 中序遍历找到后找到后一个完事儿~
      let list = [];
      const iterTree = (node) => {
        if (!node) {
          return;
        }
        if (node.left) {
          iterTree(node.left);
        }
        list.push(node);
        if(node.right) {
          iterTree(node.right);
        }
      }
      iterTree(root);
      for (let i = 0; i < list.length; i++) {
        if (list[i] === p) {
          return list[i + 1] || null;
        }
      }
      return null;
    };

    var inorderSuccessor = function(root, p) { // 中序遍历找, 但: 后继节点必定只可能是p的父节点!
      const val = p.val;
      let res = null;
      const iterTree = (node) => {
        if (!node) {
          return;
        }
        if (node.val === val && node.right) { // 找到节点 且有右子节点, 则必定是右子树的最小值.
          if (node.right) { // 有右子节点, 找到子节点的最小值;
            let subNode = node.right;
            while(subNode){
              res = subNode;
              subNode = subNode.left;
            }
          } else { // 无右子树, 不必继续搜索子树, 必是第一个比该节点大的父节点;
            return;
          }
        } else if (node.val > val) { // 或者就是node, 或者是node左子树中的某个值

        } else { // node.val < val; 

        }
      }
      iterTree(root);
      return null;
    };
  </script>
</body>
</html>