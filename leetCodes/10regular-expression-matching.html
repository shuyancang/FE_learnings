<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    /*
      给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配
      '.' 匹配任意单个字符
      '*' 匹配零个或多个前面的那一个元素
      所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

      说明:
      s 可能为空，且只包含从 a-z 的小写字母。
      p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

      示例 1:
      输入:
      s = "aa"
      p = "a"
      输出: false
      解释: "a" 无法匹配 "aa" 整个字符串。

      示例 2:
      输入:
      s = "aa"
      p = "a*"
      输出: true
      解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

      示例 3:
      输入:
      s = "ab"
      p = ".*"
      输出: true
      解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

      示例 4:
      输入:
      s = "aab"
      p = "c*a*b"
      输出: true
      解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。

      示例 5:
      输入:
      s = "mississippi"
      p = "mis*is*p*."
      输出: false
    */ 
    var isMatch = function(s, p) { // s字符串, p匹配规则
      // 动态规划: 主要思路: 取出s最末一个字符, 与p最后一个规则进行对比, 然后对比s(0 => length - 2)与p(0 => length - 2)
      var strLen = s.length;
      var matchLen = p.length;
      var dp = [];
      for (var i = 0; i < strLen.length; i++) {
        dp[i] = [];
        for(var j = 0; j < matchLen.length; j++){
          dp[i][j] = false;
        }
      }
      dp[0][0] = true; // 

    };
  </script>
</body>
</html>