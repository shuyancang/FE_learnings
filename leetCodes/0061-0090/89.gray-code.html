<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>格雷编码</title>
</head>
<body>
  <script>
    // 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。
    // 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。
    // 格雷编码序列必须以 0 开头。

    // 示例 1:
    //   输入: 2
    //   输出: [0,1,3,2]
    //   解释:
    //     00 - 0
    //     01 - 1
    //     11 - 3
    //     10 - 2
    //     对于给定的 n，其格雷编码序列并不唯一。
    //     例如，[0,2,3,1] 也是一个有效的格雷编码序列。
    //     00 - 0
    //     10 - 2
    //     11 - 3
    //     01 - 1

    // 示例 2:
    //   输入: 0
    //   输出: [0]
    //   解释: 我们定义格雷编码序列必须以 0 开头。
    //        给定编码总位数为 n 的格雷编码序列，其长度为 2 ^ n。当 n = 0 时，长度为 20 = 1。
    //        因此，当 n = 0 时，其格雷编码序列为 [0]。
    var grayCode = function(n) { // 递归 f(n) => f(n - 1)在头部间隔插入0 1即可 => 复杂度 2 ^ n 估摸着要超时
      if(n === 0) {
        return [0];
      } else if (n === 1) {
        return [0, 1];
      }
      const num = 2 ** (n - 1);
      const restList = grayCode(n - 1);
      const res = [];
      for (let i = 0; i < restList.length; i++) {
        const cur = restList[i];
        const curBig = cur + num;
        res.push(i % 2 === 0 ? cur : curBig);
        res.push(i % 2 === 0 ? curBig : cur);
      }
      return res;
    };

    // leetcode方法: 镜像对称: f(n)的结果进行镜像对称, 然后在末尾依次添加0, 1即可；
  </script>
</body>
</html>