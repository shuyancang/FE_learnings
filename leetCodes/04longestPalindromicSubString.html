<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>最长回文子串</title>
</head>
<body>
  <script>
    // 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
    // 示例 1：
    // 输入: "babad"
    // 输出: "bab"
    // 注意: "aba" 也是一个有效答案。
    // 示例 2：
    // 输入: "cbbd"
    // 输出: "bb"
    /**
    * @param {string} s
    * @return {string}
    */
    // 解法1: 暴力枚举;
    function isPalindrom(str){ // 判断一个字符串是回型;
      const len = str.length;
      const centerIndex = len | 0;
      for(let i = 0; i < len / 2; i++){
        if (str[i] !== str[len - i - 1]) {
          return false;
        }
      }
      return true;
    }

    var longestPalindrome = function(s) {
      const len = s.length;
      let maxGroup = '';
      for(let i = 0; i < len; i++){
        for(let strLen = 1; strLen <= len; strLen++){
          const tmpStrGroup = s.substring(i, strLen);
          const isPal = isPalindrom(tmpStrGroup);
          if(isPal && tmpStrGroup.length > maxGroup.length){
            maxGroup = tmpStrGroup;
          }
        }
      }
      return maxGroup;
    };

    // 解法2: 动态规划(O(n2))
    var longestPal = function (s) {
      let len = s.length, valGroup = [], maxNum = 0, maxI = 0, maxJ = 0, maxStr = '';
      for(let i = 0; i < len; i ++) {
        valGroup[i] = [];
        for(let j = 0; j < len; j++){
          if (s[len - 1 - i] === s[j]) {
            valGroup[i][j] = (valGroup[i - 1] && valGroup[i - 1][j - 1]) > 0 ?  (valGroup[i - 1][j - 1] + 1) : 1;
            if (valGroup[i][j] > maxNum) {
              maxNum = valGroup[i][j];
              maxI = i;
              maxJ = j;
            }
          } else {
            valGroup[i][j] = 0
          }
        }
      }
      while(s[maxJ]){
        maxStr = s[maxJ] + maxStr;
        maxJ--;
      }
      return maxStr;
    };

    // 解法3: manache算法
    var longestPal = function (s) {
      
      return maxStr;
    };
  </script>
</body>
</html>


