<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
    // candidates 中的每个数字在每个组合中只能使用一次。
    // 说明：所有数字（包括目标数）都是正整数。解集不能包含重复的组合。 

    // 示例 1:
    // 输入: candidates = [10,1,2,7,6,1,5], target = 8,
    // 所求解集为:
    // [
    //   [1, 7],
    //   [1, 2, 5],
    //   [2, 6],
    //   [1, 1, 6]
    // ]

    // 示例 2: 输入: candidates = [2,5,2,1,2], target = 5,
    // 所求解集为:
    // [
    //   [1,2,2],
    //   [5]
    // ]

    // 初步想法: 直接回溯递归求解，然后去重
    // 数组先提前排序, 后进行回溯递归求解, 跳过同样条件;
    // [a, a, a, b, b, c, ...]: 有若干个a + 没有a;
    var combinationSum2 = function(candidates, target) {
      const sortedArr = candidates.sort(); // 先从小到大排序
      const res = calcTool(sortedArr, target)
      return res;
    };

    // function calcTool(sortedArr, target){
    //   const res = [];
    //   function calcHelper(list, sum, idx, collections){
    //     if(sum === target){
    //       res.push(...collections);
    //       return;
    //     }
    //     if(sum > target || list.length === 0 || idx >= list.length){
    //       return;
    //     }
    //     const firtNum = list[0];
    //     calcHelper(list.slice(1, list.length), sum + firtNum, idx + 1, collections.concat(firtNum));
    //     let index = 1;
    //     while(list[idx] === list[idx + index]){
    //       index++;
    //     }
    //     calcHelper(list.slice(idx + index), sum, idx + index)
    //   }
    //   calcHelper(sortedArr, 0, 0);
    //   return res;
    // }

    function calcTool(sortedArr, target){
      const res = [];
      // function is
    }

  </script>
</body>
</html>