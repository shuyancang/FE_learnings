<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>翻转单词</title>
</head>
<body>
  <script>
    // 给你一个字符串 s ，逐个翻转字符串中的所有 单词 。
    // 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。
    // 请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。

    // 说明：
    // 输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
    // 翻转后单词间应当仅用一个空格分隔。
    // 翻转后的字符串中不应包含额外的空格。
    //  
    // 示例 1： 输入：s = "the sky is blue" 输出："blue is sky the"
    // 示例 2： 输入：s = "  hello world  " 输出："world hello"
    //   解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。
    // 示例 3： 输入：s = "a good   example" 输出："example good a"
    //   解释：如果两个单词间有多余的空格，将翻转后单词间的空格减少到只含一个。
    // 示例 4： 输入：s = "  Bob    Loves  Alice   " 输出："Alice Loves Bob"
    // 示例 5： 输入：s = "Alice does not even like bob" 输出："bob like even not does Alice"
    //  
    // 提示：
    //   1 <= s.length <= 104
    //   s 包含英文大小写字母、数字和空格 ' '
    //   s 中 至少存在一个 单词

    // 进阶：
    // 请尝试使用 O(1) 额外空间复杂度的原地解法。

    // 常规思路1: 字符串基于空格切割为数组, 翻转后, 再用空格链接;
    // 常规思路2: 从末尾开始遍历, 维护一个栈, 遇到空格就推送之前的入栈, 最后使用空格链接
    
    var reverseWords = function(s) { // 普通解法: 从末尾开始遍历, 维护一个栈
      if(!s){
        return s;
      }
      const len = s.length;
      let index = len - 1;
      let stack = [];
      let wordEnd = wordStart = len - 1;
      while(index >= 0){
        while(s[index] === ' ') {
          index--;
        }
        if(index === 0){
          return stack.join(' ');
        }
        wordEnd = index; // 某个单词的结尾index
        while(index > 0 && s[index - 1] !== ' ') {
          index--;
        }
        wordStart = index; // 该单词的头部index;
        stack.push(s.substring(wordStart, wordEnd + 1));
        index--;
      }
      return stack.join(' ')
    };

    reverseWords("the sky is blue")
    reverseWords("  hello world  ")
    reverseWords("a good   example")
    reverseWords("  Bob    Loves  Alice   ")
    reverseWords("Alice does not even like bob")
  </script>
</body>
</html>