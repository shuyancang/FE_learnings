<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>旋转数组</title>
</head>
<body>
  <script>
    // 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
    //   进阶：
    //   尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
    //   你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？

    //   示例 1:
    //     输入: nums = [1,2,3,4,5,6,7], k = 3   输出: [5,6,7,1,2,3,4]
    //     解释:
    //       向右旋转 1 步: [7,1,2,3,4,5,6]
    //       向右旋转 2 步: [6,7,1,2,3,4,5]
    //       向右旋转 3 步: [5,6,7,1,2,3,4]
    //   示例 2:
    //     输入：nums = [-1,-100,3,99], k = 2    输出：[3,99,-1,-100]
    //     解释: 
    //       向右旋转 1 步: [99,-1,-100,3]
    //       向右旋转 2 步: [3,99,-1,-100]
    //   提示：
    //     1 <= nums.length <= 2 * 104
    //     -231 <= nums[i] <= 231 - 1
    //     0 <= k <= 105

      // 方法一显然是找到旋转点(k % n), 先往右遍历, 再从0往后遍历
      // 方法二直接模拟队列操作, 模拟旋转步骤
      // 方法三O(1): 先进性局部计算在进行整体旋转: 
      var rotate = function(nums, k) {
        if(!nums || !(nums.length > 0)){
          return;
        }
        const len = nums.length;
        const step = k % len;
        let mid = len - step - 1;
        let start = 0;
        let end = len - 1;
        while(start < mid){
          const tmp = nums[start];
          nums[start] = nums[mid];
          nums[mid] = tmp;
          start++;
          mid--;
        }
        mid = len - step;
        while(mid < end){
          const tmp = nums[end];
          nums[end] = nums[mid];
          nums[mid] = tmp;
          mid++;
          end--;
        }
        start = 0;
        end = len - 1;
        while(start < end){
          const tmp = nums[start];
          nums[start] = nums[end];
          nums[end] = tmp;
          start++;
          end--;
        }
      };
  </script>
</body>
</html>