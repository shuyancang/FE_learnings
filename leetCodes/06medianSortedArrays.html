<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>


  <script>
    var mergeArr = function(left, right){ // 有序数组合并
      let sortedArr = [];
      let leftI = 0; rightI = 0;
      while(left[leftI] || right[rightI]){
        let leftNum = left[leftI], rightNum = right[rightI];
        if (leftNum && rightNum) {
          if(leftNum <= rightNum){
            sortedArr.push(leftNum);
            leftI++;
          } else {
            sortedArr.push(rightNum);
            rightI++;
          }
        } else if (leftNum){
          sortedArr.push(leftNum);
          leftI++;
        } else {
          sortedArr.push(rightNum);
          rightI++;
        }
      }
      return sortedArr;
    }

    var mergerFunc = function(arr){ // 回忆一下归并排序(递归实现)
      const len = arr.length;
      const mid = Math.ceil(len / 2);
      if (arr.length <= 1) {
        return arr;
      }
      let left = [], right = [];
      for(let i = 0; i < mid; i++){
        left.push(arr[i]);
        arr[mid + i] && right.push(arr[mid + i]);
      }
      return mergeArr(mergerFunc(left), mergerFunc(right));
    }

    var mergeWhileFunc = function(arr){ // while方法实现归并排序: 
      const len = arr.length;
      const mid = Math.ceil(len / 2);
      if (arr.length <= 1) {
        return arr;
      }
      let newArr = [];
      for(let i = 0; i < len; i++){
        newArr.push([arr[i]]);
      } // 直接分解, 逆向归并
      while(newArr.length > 1){
        const tmpLen = newArr.length;
        const mid = Math.ceil(tmpLen / 2); // 0 => 1.2, 1 => 3, 4, ; 2 => 5
        for(let i = 0; i < mid; i++) {
          let tmpCeil = [];
          let leftArr = newArr[2 * i];
          let rigthArr = newArr[2 * i + 1];
          let leftIndex = 0; rightIndex = 0;
          while ((leftArr && leftArr[leftIndex]) || (rigthArr && rigthArr[rightIndex])) {
            if(!leftArr || !leftArr[leftIndex]){
              tmpCeil.push(rigthArr[rightIndex]);
              rightIndex++;
            } else if (!rigthArr || !rigthArr[rightIndex]) {
              tmpCeil.push(leftArr[leftIndex]);
              leftIndex++;
            } else if (leftArr[leftIndex] < rigthArr[rightIndex]) {
              tmpCeil.push(leftArr[leftIndex]);
              leftIndex++;
            } else {
              tmpCeil.push(rigthArr[rightIndex]);
              rightIndex++;
            }
          }
          newArr[i] = tmpCeil;
        }
        newArr.length = Math.ceil(tmpLen / 2);
      }
      return newArr[0];
    }

    var findMedianSortedArrays = function(nums1, nums2){ // 解法1： 找第k个小的数，每次抛弃掉数组前k/2 进行比较,
      var aLen = nums1.length;
      var bLen = nums2.length;
      if ((aLen + bLen) % 2 === 1) {
        return findNum(nums1, nums2, (aLen + bLen + 1) / 2);
      } else {
        return (findNum(nums1, nums2, (aLen + bLen) / 2) + findNum(nums1, nums2, (aLen + bLen) / 2 + 1)) / 2;
      }
    }

    var findNum = function(aArr, bArr, orderNum){ // 找到有序数组aArr, bArr中, 第小的数;
      var aLen = aArr.length, bLen = bArr.length, aIndex = 0, bIndex = 0;
      var k = parseInt(orderNum / 2);
      // 要找第10个: 5; 2; 1; 1; => orderNum = 1找到对应的数据并返回;
      // 要找第8个: 4; 2; 1
      if (aLen === 0) {
        return bArr[orderNum - 1];
      } else if (bLen === 0) {
        return aArr[orderNum - 1];
      }
      while(orderNum > 0) {
        if (orderNum === 1) { // 最后一个数值即是结果;
          if (aArr[aIndex] === undefined) {
            return bArr[bIndex];
          } else if (bArr[bIndex] === undefined) {
            return aArr[aIndex];
          }
          return Math.min(aArr[aIndex], bArr[bIndex]);
        }
        
        if (aIndex + k > aLen) {
          k = aLen - aIndex;
        } else if (bIndex + k > bLen) {
          k = bLen - bIndex;
        }
        var aNum = aArr[aIndex + k - 1], bNum = bArr[bIndex + k - 1];
        orderNum -= k;
        if (aNum <= bNum) {
          aIndex += k;
          if (aIndex === aLen) { // a数组使用完了~
            return bArr[bIndex + orderNum - 1];
          }
        } else {
          bIndex += k;
          if (bIndex === bLen) {
            return aArr[aIndex + orderNum - 1];
          }
        }
        k = parseInt(orderNum / 2);
      }
    }

    var findMedianSortedArrays = function (nums1, nums2) { // 解法2: 几何对称,
      var shortArr = nums1, longArr = nums2;
      if (nums1.length > nums2) {
        shortArr = nums2;
        longArr = nums1;
      }
      var shortLen = shortArr.length; longLen = longArr.length;
      var totalUnit = shortLen + longLen; // 总数
      if(shortLen === 0) { // 短数组长度0 => 中位数直接获得
        return (longLen % 2 === 1) ? longArr[(longLen - 1) / 2] : (longArr[longLen / 2] + longArr[longLen / 2 - 1]) / 2;
      } else if (longLen === 1) { // 长短数组均只有一个元素的情况
        return (shortArr[0] + longArr[0]) / 2;
      } else if (shortLen === 1 && longLen % 2 === 1) { // 短数组只有一个长度, 长数组为奇数(>=3)长度
        var longMedian =  longArr[(longLen - 1) / 2];
        var smallerMedian = longArr[(longLen - 3) / 2];
        var biggerMedian = longArr[(longLen + 1) / 2];
        return longMedian >= shortArr[0] ? (Math.max(smallerMedian, shortArr[0]) + longMedian) / 2 : (Math.min(biggerMedian, shortArr[0]) + longMedian) / 2;
      }
      var shortIndex = Math.ceil(shortLen / 2) - 1; // 短数组左侧用于比较的数据个数; => shortIndex = shortLeftLen - 1;
      var longIndex = Math.floor(longLen / 2) - 1; // 长数组左侧用于比较数据个数; => longIndex = longLeftLen - 1;
      // 进入循环的前提: 短数组长度 >= 2;
      var half = parseInt(shortLen / 2);
      while(true){
        // 正常情况, 长短数组均左右值均存在正常 比较+移动index => 直接找到了对应的中间点; 
        var shortLeftNum = shortArr[shortIndex], 
            shortRightNum = shortArr[shortIndex + 1],
            longLeftNum = longArr[longIndex],
            longRightNum = longArr[longIndex + 1];
        if (shortLeftNum <= longRightNum && longLeftNum <= shortRightNum) { // 找到了对应的位置
          if (totalUnit % 2 === 1) { // 奇数 => 第 (n + 1) / 2 个数;
            var resultUnit = (n + 1) / 2;
            var leftUnits = shortIndex + longIndex + 2; // 左侧数据个数;
            return (resultUnit = leftUnits) ? Math.max(shortLeftNum, longLeftNum) : Math.min(shortRightNum, longRightNum);
          } else { // 偶数 => 四个数中的两个最接近数的 平均值
            return (Math.max(shortLeftNum, longLeftNum) + Math.min(shortRightNum, longRightNum)) / 2;
          }
        } else if (shortLeftNum > longRightNum) { // 短数组左侧 大于 长数组右侧数据 => shortIndex应减小, longIndex增大
          if (shortIndex === 0 || longIndex === longLen - 1) { // 无法继续移动 => 短数组最小的数都大于长数组最大的数;
            var tmpMedianBigger = longArr[(totalUnit - 1) / 2];
            var medianBigger = tmpMedianBigger === undefined ? shortIndex[0] : tmpMedianBigger;
            if (totalUnit % 2 === 1) { // 奇数
              return medianBigger;
            } else { // 偶数
              return (longArr[(totalUnit - 3) / 2] + medianBigger) / 2;
            }
          }
          shortIndex -= half;
          longIndex += half;
        } else if (longLeftNum > shortRightNum) { // 长数组左侧 大于 短数组右侧数据 => shortIndex应增大, longIndex减小
          if (shortIndex === shortLen - 1 || longIndex === 0) { // 短数组最大的数都小于长数组最小的数;
            // var tmpMedianSmaller = longArr[(totalUnit + 1) / 2 - (shortIndex + 1) - 1];
            // var tmpMedianSmaller = longArr[(totalUnit + 1) / 2 - (shortIndex + 1)] === undefined ? shortIndex[0] : longArr[(totalUnit - 1) / 2];
            if (totalUnit % 2 === 1) { // 奇数
              // return tmpMedianBigger;
            } else { // 偶数
              // return (longArr[(totalUnit - 3) / 2] + tmpMedianBigger) / 2;
            }
          }
          shortIndex += half;
          longIndex -= half;
        }
        half = parseInt(half / 2) > 0 ? parseInt(half / 2) : 1;
      }






      var shortIndex = Math.ceil(shortLen / 2) - 1;
      var longIndex = Math.floor(longLen / 2) - 1;
      var compareLength = Math.ceil(shortLen / 2);

      var debuggerNum = 0;
      while(true){
        debuggerNum++;
        if(debuggerNum > 1000) {
          return ['死循环', shortIndex, longIndex];
        }
        // 短数组如果移动完依然没找到，则必定在长数组对应index找到;
        var shortLeftNum = shortArr[shortIndex], shortRightNum = shortArr[shortIndex + 1];
        var longLeftNum = longArr[longIndex], longRightNum = longArr[longIndex + 1];
        compareLength = parseInt(compareLength / 2) || 1;
        if (shortLeftNum === undefined) { // 左边到头了。即短数组内所有数都比中位数大;
          return (totalNum % 2 === 1) ? longArr[(totalNum - 1) / 2] : (longArr[totalNum / 2] + longArr[totalNum / 2 - 1]) / 2;
        }
        if (shortLeftNum > longRightNum) { // shortIndex应该减小, longIndex应该增大
          shortIndex -= compareLength;
          longIndex += compareLength;
        } else if (longLeftNum > shortRightNum) { // shortIndex 增大, longIndex减小
          if (shortIndex === shortLen - 1) { // 短数组尽头, 即短数组内所有数都比中位数小;
            return (totalNum % 2 === 1) ? longArr[(totalNum - 1) / 2] : (longArr[totalNum / 2] + longArr[totalNum / 2 - 1]) / 2;
          }
          shortIndex += compareLength;
          longIndex -= compareLength;
        }

        if (shortLeftNum <= longRightNum && longLeftNum <= shortRightNum) { // 找到正确的位置！满足条件！
          // 总长度为奇数 => 中位数是左侧大的那个; 偶数 => 中位数是(左边大数 + 右边小数) / 2
          var leftBigger = Math.max(shortLeftNum, longLeftNum);
          var rightMiner = Math.min(shortRightNum, longRightNum);
          return (totalNum % 2 === 1) ? leftBigger : (leftBigger + rightMiner) / 2;
        }
      }


      return [];
    }
    
  </script>
</body>
</html>