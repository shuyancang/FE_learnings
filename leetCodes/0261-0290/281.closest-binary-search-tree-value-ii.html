<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>最接近二叉搜索树的值II</title>
</head>
<body>
  <script>
    // 给定一个不为空的二叉搜索树和一个目标值 target，请在该二叉搜索树中找到最接近目标值 target 的 k 个值。
    // 注意：
    //   给定的目标值 target 是一个浮点数
    //   你可以默认 k 值永远是有效的，即 k ≤ 总结点数
    //   题目保证该二叉搜索树中只会存在一种 k 个值集合最接近目标值
    // 示例： 输入: root = [4,2,5,1,3]，目标值 = 3.714286，且 k = 2
    //       4
    //     / \
    //     2   5
    //   / \
    //   1   3
    // 输出: [4,3]
    // 拓展： 假设该二叉搜索树是平衡的，请问您是否能在小于 O(n)（n 为总结点数）的时间复杂度内解决该问题呢？
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @param {number} target
     * @param {number} k
     * @return {number[]}
     */

    // 思路1, 显然遍历得到一个已排序数组, 找到target所处位置, 两边
    var closestKValues = function(root, target, k) {

    };
      </script>
</body>
</html>