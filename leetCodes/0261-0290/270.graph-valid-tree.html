<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>以图判树</title>
</head>
<body>
  <script>
    // 给定从 0 到 n-1 标号的 n 个结点，和一个无向边列表（每条边以结点对来表示），请编写一个函数用来判断这些边是否能够形成一个合法有效的树结构。
    // 示例 1：   输入: n = 5, 边列表 edges = [[0,1], [0,2], [0,3], [1,4]]                 输出: true
    // 示例 2:    输入: n = 5, 边列表 edges = [[0,1], [1,2], [2,3], [1,3], [1,4]]          输出: false
    // 注意：你可以假定边列表 edges 中不会出现重复的边。由于所有的边是无向边，边 [0,1] 和边 [1,0] 是相同的，因此不会同时出现在边列表 edges 中。
    
    var validTree = function(n, edges) { // 判断edges是否成环;
      let visited = [], relataionMap = new Map();
      for(let i = 0; i < n; i++){
        visited.push(0); // 0未访问, 1访问中, 2完成访问
        relataionMap.set(i, new Set());
      }
      for(let i = 0; i < edges.length; i++){
        const [start, end] = edges[i];
        relataionMap.set(start, relataionMap.get(start).add(end));
        relataionMap.set(end, relataionMap.get(end).add(start));
      }
      const dfs = (node, pre) => {
        const relations = relataionMap.get(node); // 这个节点对应的所有边节点
        visited[node] = 1;
        for(let cur of relations){
          if(visited[cur] === 2 || node === pre) { // 已经访问完成的干净节点
            continue;
          } else if (visited[cur] === 1) { // 出现循环, 有错误
            return false;
          } else if (!dfs(cur)) { // 一个未访问的节点
            return false;
          }
        }
        visited[node] = 2;
        return true;
      }
      for(let i = 0; i < n; i++){
        const isTreeNode = dfs(i);
        if(!isTreeNode) {
          return false;
        }
      }
      return true;
    };
    // validTree(5, [[0,1],[0,2],[0,3],[1,4]]) // true
    // validTree(5, [[0,1], [1,2], [2,3], [1,3], [1,4]]) // false
    // 
  </script>
</body>
</html>