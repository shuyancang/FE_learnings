# performanceOptimization
前端性能优化


## 1. 雅虎军规
* 减少http请求数 - css, scripts, 图片(雪碧图等)
* 减少DNS的查找次数 - 利用dns预解析提升页面速度(link ref='dns-prefetch' href)
* 避免跳转: 301, 302
* 可缓存的ajax: add an expires or a cache-control header
* 推迟加载内容, 不必要的内容可在相应触发条件时再去加载
* 预加载: 浏览器空闲时，提前加载可能使用的内容。meta prefetch
* 减少dom元素数量
* 根据域名划分内容: 不同的资源不同的内容尽量进行处理
* iframe数量最小: iframe即使内容为空也需要时间, 且会阻止页面加载, 且没有语义
* htpp不要出现404
* CDN使用分发网络
* 为文件头添加缓存设置: 静态可以设置永不过期
* gzip压缩文件内容
* 配置etag: 匹配机制
* 尽早刷新输出缓冲 - 在模板时候影响, 现在前后端分离基本不用考虑
* 使用get完成ajax完成, post发送过程是两步走
* 将样式表置于顶部: 样式表放在head会使页面有步骤的加载显示
* 避免使用css表达式
* 使用外部的js和css
* 削减js和css
* 使用<link>代替@import
* 避免使用滤镜
* 把脚本置于页面底部
* 剔除重复脚本
* 减少DOM访问： 缓存已经访问过的元素
* 开发智能事件处理程序
* 减少cookie体积, 可以考虑使用localstorage
* 对于页面内容使用无cookie域名
* 优化图像， png， 
* 优化css spirite
* 不要在html中缩放图像
* favicon.ico要小且可以缓存
* 保持单个内容小于25k
* 打包组件成复合文本


## 2. 面向切面的概念(AOP)
* 针对业务处理过程中的切面进行提取; 面对的是处理过程中的某个步骤或阶段, 以获得逻辑过程中各部分之间的低耦合性的隔离效果。
* 无侵入的代码方式 查看./src/aop

## 3. 前端开发高级调试

* 断点及捕捉事件绑定
******************************
  1. sources找到相关代码片段 => 选中某行打上断点 => 右侧 上下按钮进行上下步调试, 弯箭头是进入下一个function , 左下方花括号可以代码自动折行展示
  2. 找到相应html的事件: 审查元素 该元素的EventListeners看到绑定的事件
  3. 调试台捕捉到html右键时候, 点击右侧 -> break on -> node removal可以定位查找对该html的操作, attributes - 属性, subtree - 节点也可以进行捕捉
  ******************************
  * Audits和Chrome性能插件
  ******************************
  1. Audits当前网页性能分析 => f12调试台audits页面, 运行后生成报告。
  2. performanceTracer插件,安装后点击可以将页面所有时间进行可视化的输出 -> 但依然不足以进行详细的分析。
  3. Page Speed插件, start analysis => 点击后可以查看到每个步骤加载的耗时。上面有更为明确提示的优化项目
  4. performance.timing: 更专业的性能优化api事件。=> 可以更详细的分析当前页面的渲染与性能
******************************

* 4. Timeline掌握帧渲染模式
******************************
  1. 网页动画做到每秒60帧, 就会跟显示器同步刷新, 每次重新渲染时间不能超过16.66毫秒
  2. 蓝色： 网络通信和html解析；黄色： js执行；紫色： 样式计算和布局，重排；绿色： 重绘
  3. window.requestAnimationFrame => 下一帧; window.requestIdleCallback => 下几次重新渲染时
  4. 触发分层: 获取dom并分割成多个层, 将每个层独立绘制进位图中, 将层作为纹理上传至GPU, 复合多个层来生成最终的屏幕图像
  5. DOM子树渲染层 -> RenderObject -> GraphicsContext; Composior -> 渲染层子树的图形层 -> RenderLayer -> RenderObject
  6. 如何开发不会导致重排: 样式表越简单, 重绘重排越快; 重排和重绘DOM元素层级越高成本就越高; table元素的重绘重排成本高于div; 尽量不要把读操作和写操作放在一个语句; 统一改变样式; 缓存重排结果; 离线DOM Fragment/clone; 虚拟DOM React; 必要时候Display:none 不可见元素不影响重排重绘, visibility堆重排影响不影响重绘
  7. 网页生成时至少会渲染一次, 用户访问过程中还会不断渲染, 修改DOM, 修改样式表, 用户事件都会导致网页重新渲染
  8. 重新渲染需要生成布局(重排)和重新绘制(重绘), 重绘不一定需要重排(修改某个元素颜色), 重排必然导致重绘(修改一个页面元素的位置)
******************************

* 5. Profiles分析具体问题
******************************
  1. v8 profiles去寻找js相关内容
  2. node-inspector插件可以检测查看node的性能相关; webkit技术内幕(书)
  3. node内存泄露知识点: 全局变量需要进程退出才释放
  4. 闭包引用中间函数, 中间函数也不能释放, 会使原始的作用域也不会释放, 作用域不被释放它产生的内存占用也不会释放。因此使用过后需要重置为null等待垃圾回收
  5. 谨慎使用内存当缓存, 建议采用redis或者memcached, 好处: 外部缓存软件有着良好的缓存过期淘汰策略以及自由的内存管理, 不影响node主进程的性能。减少内部常驻内存的对象数量垃圾回收更高效率, 进程间共享缓存。
******************************

* 6. 网红平台性能优化
实现方式: polling(ajax); Long Polling(comet); Flash; Web socket
*************




*************




















