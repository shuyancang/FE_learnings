# 1. 
先关注: react, react-dom, react-reconciler调度器
createElement的分析, $$typeof的唯一标识及效果
React.Children.map([1, 2, 3, 4], (item) => <div>{item}</div>); 这种方式也能够对数组进行处理，同时第一个参数会进行类型校验+扁平化；

React解读流程 -> 流程内重要知识及函数: 
********
  ReactElement;
  ReactChilren;
  ReactFiber: 
    v16以前调度算法自顶而下递归更新, 不可打断不可取消, 主线程会出现暂用掉帧卡顿的现象;
    fiber调度: reconciliation(以fiber为基本单位，执行完询问是否有更高优先级任务 => 标记side effect) + commit(处理标记side effect-更新, 不可中断); 
    1.1 原本是数组结构现在变为链表结构 => next调用记录, 可随时标记中断;
    1.2 每个任务都有过期时间和优先级, 两个维度进行渲染任务调度;
    1.3 reconciliation可以被打断(不会渲染-基于dom-diff进行标记), commit不可打断(渲染);
  常用节点类-Root, RootType, FiberRoot{
      current: 当前应用对应的Fiber对象,
      containerInfo: root节点,
      finishedWork: 指向已经完成工作的Fiber Tree Root; Fiber链表结构
      expirationTime: 过期时间
    },
  FiberNode {
    this.type: 类型
    this.return: 父级FiberNode
    this.child: 第一个子FiberNode
    this.sibling: 紧邻的下一个兄弟FiberNode
    this.ref: 真实的实例
    this.pendingProps: 新的props
    this.memoizedProps: 旧props
    this.updateQueue: 更新队列-队列里放着即将发生的更变状态 => 最终会遍历该链表
    this.memorizedState: 经过所有流程处理后的当前state;
    this.effectTag: 更新类型-replace, delete, update
    this.nextEffect: 下一个将要处理的副作用
    this.firstEffect: 第一个要处理的副作用
    this.lastEffect: 最后一个要处理的副作用
    this.expirationTime: 过期时间; -> 和优先级有关
    this.childExpirationTime: 子fiber中优先级最高的fiber
    this.alternate: 对应上一个状态fiber, 存储了之前的镜像;
  }
  react启动方式的三种模式 
    ConcurrentMode模式-ReactDOM.createRoot() => 实验中, 打算作为React的默认开发模式 => 开启所有新功能
    legacy模式-ReactDOM.render() => 当前使用的方式
    blocking模式-ReactDOM.render => React.createBlockingRoot(); 实验中, 作为迁移到concurent模式的第一个步骤
  
  要了解的几个调度知识:
    expirationTime的计算: 过期时间计算函数(间隔在precision)
    不同的优先级定义: 
    enqueueUpdate(current, update); // 添加update到quene队列
    scheduleWork(current, expirationTime); // 调度和更新当前current对象;
    任务的不同状态常量: NoContext BatchedContext  EventContext DiscreteEventContext LegacyUnbatchedContext RenderContext CommitContext;
    ensureRootIsScheduled在宏任务中执行调度; 匹配上的时候, 才执行;
    利用MessageChannel进行宏任务的分发, 实现事件循环中的任务执行;
    reconcileChildFibers给Fiber打上effect-tag标记
    updateHostRoot: 初次则创建Fiber节点; 非初次则更新并effect-tag(dom diff)
    reconcileChildren
********

# 2. React整体逻辑汇总:
ReactDom.render()整体流程大致做了些什么;
***********
  react启动的三种模式, legacy/concurrent/blocking
  创建Root, ReactRoot, FiberRoot, FiberNode, 他们的与属性主要有哪些;
  FiberRoot: (current, containerInfo, finishedWork, expirationTime)
  FiberNode: (tag, key, elementType, type, return ,child, sibling, memoizedProps, updateQueue, effectTag, nextEffect, firstEffect, lastEffect, expirationTyme, alternate) --> 深度优先遍历。 
  2.1 首先创建ReactRoot, 封装callback函数;
  2.2 执行unbatchedUpdates 不做批处理(batchUpdate批处理 -> 对应其他节点上使用); 调用updateContainer; 
    =>  拿到FiberNode, 
        设置expirationTime, 
        封装callback, 
        新建update并添加到fiber的updateQueue中, 
        进入scheduleWork(核心: 调度流程)
  2.3 核心, 调度流程scheduleWork
    scheduleWork
     => 只要涉及到更新, 都会从schedulework开始走;
        找到rootFiber并遍历更新子节点的expirationTime;
        判断是否有更高优先级任务打断当前正在执行的任务
        if: expirationTime === Sync 
          if 处于 unbatchedUpdates中 && 不在render阶段和commit阶段: performSyncWorkOnRoot
          else ensureRootIsScheduled
        else ensureRootIsScheduled
    performSyncWorkOnRoot: render阶段, commit阶段
    ensureRootIsScheduled:
      有过期任务将优先级设置为最高立即执行
      没有新任务, return;
      有历史任务还没有执行完的, 对比新任务和历史任务的优先级
        历史任务优先级高: 继续调度历史任务
        新任务优先级高: 打断取消历史任务, 重新安排新任务
      根据新任务的优先级, 调用scheduleCallback调用unstable_scheduleCallback
    unstale_scheduleCallback: messageChannel里执行performSyncWorkOnRoot
***********

# 3. 


# 4. 
